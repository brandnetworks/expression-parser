{"version":3,"sources":["expression-parser.min.js","/source/expression-parser.js"],"names":["_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","i","length","descriptor","protoProps","staticProps","prototype","global","factory","exports","module","define","amd","ExpressionParser","this","isDefined","isString","isBoolean","helpers__isNumber","isDate","toString","call","isRegExp","copy","source","isArray","map","Date","getTime","dest","RegExp","match","lastIndex","hasOwnProperty","defaults","options","arguments","undefined","defaults_","keys","forEach","_AST$PRECEDENCE","OPERATORS","+","-","*","/","%","==","!=","<",">","<=",">=","&&","||","!","=","|","ESCAPE","n","f","r","t","v","'","\"","getPrototypeOf","Array","Lexer","text","index","tokens","ch","charAt","readString","isNumber","peek","readNumber","isIdent","readIdent","is","push","isWhitespace","ch2","ch3","op1","op2","op3","token","operator","throwError","chars","indexOf","num","error","start","end","colStr","substring","Error","number","toLowerCase","peekCh","isExpOperator","constant","Number","slice","identifier","quote","string","rawString","escape","hex","String","fromCharCode","parseInt","rep","_ast__DEFAULT_OPTIONS","AST","lexer","constants","true","type","Literal","false","null","lex","filterChain","expect","left","expression","filter","ternary","test","logicalOR","alternate","consequent","consume","ConditionalExpression","logicalAND","LogicalExpression","right","equality","relational","BinaryExpression","additive","multiplicative","unary","UnaryExpression","prefix","argument","primary","arrayDeclaration","object","next","MemberExpression","property","computed","baseExpression","args","result","CallExpression","callee","Identifier","name","elements","peekToken","ArrayExpression","properties","Property","kind","ObjectExpression","msg","e1","e2","e3","e4","peekAhead","shift","PRECEDENCE","LOGICAL_EXPRESSION_PRECEDENCE","BINARY_EXPRESSION_PRECEDENCE","parser__DEFAULT_OPTIONS","Parser","astBuilder","expr1","expr2","prec","oprec","ast","parent","_this","str","expr","precedence","arg","join","JSON","stringify","_this2","locals","filters","e","eval","apply","res","prop","err","bubble","info","message","_this3"],"mappings":"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","file":"expression-parser.min.js","sourcesContent":[null,"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  factory((global.ExpressionParser = {}))\n}(this, function (exports) { 'use strict';\n\n  const OPERATORS = {\n    '+': true,\n    '-': true,\n    '*': true,\n    '/': true,\n    '%': true,\n    '==': true,\n    '!=': true,\n    '<': true,\n    '>': true,\n    '<=': true,\n    '>=': true,\n    '&&': true,\n    '||': true,\n    '!': true,\n    '=': true,\n    '|': true\n  };\n\n  const ESCAPE = {\n    'n': '\\n',\n    'f': '\\f',\n    'r': '\\r',\n    't': '\\t',\n    'v': '\\v',\n    '\\'': '\\'',\n    '\"': '\"'\n  };\n\n  var getPrototypeOf = Object.getPrototypeOf;\n\n  function isUndefined(value) {\n    return typeof value === 'undefined';\n  }\n\n  function isDefined(value) {\n    return typeof value !== 'undefined';\n  }\n\n  function isObject(value) {\n    return value !== null && typeof value === 'object';\n  }\n\n  function isString(value) {\n    return typeof value === 'string';\n  }\n\n  function isBoolean(value) {\n    return typeof value === 'boolean';\n  }\n\n  function helpers__isNumber(value) {\n    return typeof value === 'number';\n  }\n\n  function isDate(value) {\n    return toString.call(value) === '[object Date]';\n  }\n\n  var isArray = Array.isArray;\n\n  function isFunction(value) {\n    return typeof value === 'function';\n  }\n\n  function isRegExp(value) {\n    return toString.call(value) === '[object RegExp]';\n  }\n\n  function copy(source) {\n    if (isArray(source)) {\n      return source.map(copy);\n    } else if (isDate(source)) {\n      return new Date(source.getTime());\n    } else if (isRegExp(source)) {\n      let dest = new RegExp(source.source, source.toString().match(/[^\\/]*$/)[0]);\n      dest.lastIndex = source.lastIndex;\n      return dest;\n    } else if (helpers__isNumber(source) || isString(source) || isBoolean(source)) {\n      return source;\n    } else {\n      let dest = {};\n      for (let key in source) {\n        if (source.hasOwnProperty(key)) {\n          dest[key] = copy(source[key]);\n        }\n      }\n      return dest;\n    }\n  }\n\n  function defaults(options = {}, defaults_ = {}) {\n    Object.keys(defaults_).forEach(key => {\n      if (typeof options[key] === 'undefined') {\n        options[key] = copy(defaults_[key]);\n      }\n    });\n    return options;\n  }\n\n  class Lexer {\n\n    constructor(options) {\n      this.options = options;\n    }\n\n    lex(text) {\n      this.text = text;\n      this.index = 0;\n      this.tokens = [];\n\n      while (this.index < this.text.length) {\n        let ch = this.text.charAt(this.index);\n        if (ch === '\"' || ch === '\\'') {\n          this.readString(ch);\n        } else if (this.isNumber(ch) || ch === '.' && this.isNumber(this.peek())) {\n          this.readNumber();\n        } else if (this.isIdent(ch)) {\n          this.readIdent();\n        } else if (this.is(ch, '(){}[].,;:?')) {\n          this.tokens.push({ index: this.index, text: ch });\n          this.index++;\n        } else if (this.isWhitespace(ch)) {\n          this.index++;\n        } else {\n          let ch2 = ch + this.peek();\n          let ch3 = ch2 + this.peek(2);\n          let op1 = OPERATORS[ch];\n          let op2 = OPERATORS[ch2];\n          let op3 = OPERATORS[ch3];\n          if (op1 || op2 || op3) {\n            let token = op3 ? ch3 : (op2 ? ch2 : ch);\n            this.tokens.push({ index: this.index, text: token, operator: true });\n            this.index += token.length;\n          } else {\n            this.throwError('Unexpected next character', this.index, this.index + 1);\n          }\n        }\n      }\n      return this.tokens;\n    }\n\n    is(ch, chars) {\n      return chars.indexOf(ch) !== -1;\n    }\n\n    peek(i) {\n      let num = i || 1;\n      return (this.index + num < this.text.length) ? this.text.charAt(this.index + num) : false;\n    }\n\n    isNumber(ch) {\n      return ('0' <= ch && ch <= '9') && typeof ch === 'string';\n    }\n\n    isWhitespace(ch) {\n      // IE treats non-breaking space as \\u00A0\n      return (ch === ' ' || ch === '\\r' || ch === '\\t' ||\n      ch === '\\n' || ch === '\\v' || ch === '\\u00A0');\n    }\n\n    isIdent(ch) {\n      return ('a' <= ch && ch <= 'z' ||\n      'A' <= ch && ch <= 'Z' ||\n      '_' === ch || ch === '$');\n    }\n\n    isExpOperator(ch) {\n      return (ch === '-' || ch === '+' || this.isNumber(ch));\n    }\n\n    throwError(error, start, end) {\n      end = end || this.index;\n      let colStr = (isDefined(start)\n        ? 's ' + start + '-' + this.index + ' [' + this.text.substring(start, end) + ']'\n        : ' ' + end);\n      throw Error(`Lexer Error: ${error} at column${colStr} in expression [${this.text}].`);\n    }\n\n    readNumber() {\n      let number = '';\n      let start = this.index;\n      while (this.index < this.text.length) {\n        let ch = this.text.charAt(this.index).toLowerCase();\n        if (ch === '.' || this.isNumber(ch)) {\n          number += ch;\n        } else {\n          let peekCh = this.peek();\n          if (ch === 'e' && this.isExpOperator(peekCh)) {\n            number += ch;\n          } else if (this.isExpOperator(ch) &&\n            peekCh && this.isNumber(peekCh) &&\n            number.charAt(number.length - 1) === 'e') {\n            number += ch;\n          } else if (this.isExpOperator(ch) &&\n            (!peekCh || !this.isNumber(peekCh)) &&\n            number.charAt(number.length - 1) === 'e') {\n            this.throwError('Invalid exponent');\n          } else {\n            break;\n          }\n        }\n        this.index++;\n      }\n      this.tokens.push({\n        index: start,\n        text: number,\n        constant: true,\n        value: Number(number)\n      });\n    }\n\n    readIdent() {\n      let start = this.index;\n      while (this.index < this.text.length) {\n        let ch = this.text.charAt(this.index);\n        if (!(this.isIdent(ch) || this.isNumber(ch))) {\n          break;\n        }\n        this.index++;\n      }\n      this.tokens.push({\n        index: start,\n        text: this.text.slice(start, this.index),\n        identifier: true\n      });\n    }\n\n    readString(quote) {\n      let start = this.index;\n      this.index++;\n      let string = '';\n      let rawString = quote;\n      let escape = false;\n      while (this.index < this.text.length) {\n        let ch = this.text.charAt(this.index);\n        rawString += ch;\n        if (escape) {\n          if (ch === 'u') {\n            let hex = this.text.substring(this.index + 1, this.index + 5);\n            if (!hex.match(/[\\da-f]{4}/i)) {\n              this.throwError('Invalid unicode escape [\\\\u' + hex + ']');\n            }\n            this.index += 4;\n            string += String.fromCharCode(parseInt(hex, 16));\n          } else {\n            let rep = ESCAPE[ch];\n            string = string + (rep || ch);\n          }\n          escape = false;\n        } else if (ch === '\\\\') {\n          escape = true;\n        } else if (ch === quote) {\n          this.index++;\n          this.tokens.push({\n            index: start,\n            text: rawString,\n            constant: true,\n            value: string\n          });\n          return;\n        } else {\n          string += ch;\n        }\n        this.index++;\n      }\n      this.throwError('Unterminated quote', start);\n    }\n  }\n\n  exports.Lexer = Lexer;\n\n  const _ast__DEFAULT_OPTIONS = {};\n\n  class AST {\n\n    constructor(lexer, options) {\n      this.lexer = lexer;\n      this.options = defaults(options, _ast__DEFAULT_OPTIONS);\n      this.constants = {\n        'true': { type: AST.Literal, value: true },\n        'false': { type: AST.Literal, value: false },\n        'null': { type: AST.Literal, value: null },\n        'undefined': { type: AST.Literal, value: undefined }\n      };\n    }\n\n    ast(text) {\n      this.text = text;\n      this.tokens = this.lexer.lex(text);\n\n      let value = this.filterChain();\n      if (this.peek(';')) {\n        // Allow trailing semicolon, not required\n        this.expect(';');\n      }\n      if (this.tokens.length !== 0) {\n        this.throwError('is an unexpected token', this.tokens[0]);\n      }\n      return value;\n    }\n\n    filterChain() {\n      let left = this.expression();\n      let token;\n      while ((token = this.expect('|'))) {\n        left = this.filter(left);\n      }\n      return left;\n    }\n\n    expression() {\n      return this.ternary();\n    }\n\n    ternary() {\n      let test = this.logicalOR();\n      let alternate;\n      let consequent;\n      if (this.expect('?')) {\n        consequent = this.expression();\n        if (this.consume(':')) {\n          alternate = this.expression();\n          return { type: AST.ConditionalExpression, test: test, consequent: consequent, alternate: alternate };\n        }\n      }\n      return test;\n    }\n\n    logicalOR() {\n      let left = this.logicalAND();\n      while (this.expect('||')) {\n        left = { type: AST.LogicalExpression, operator: '||', left: left, right: this.logicalAND() };\n      }\n      return left;\n    }\n\n    logicalAND() {\n      let left = this.equality();\n      while (this.expect('&&')) {\n        left = { type: AST.LogicalExpression, operator: '&&', left: left, right: this.equality() };\n      }\n      return left;\n    }\n\n    equality() {\n      let left = this.relational();\n      let token;\n      while ((token = this.expect('==', '!='))) {\n        left = { type: AST.BinaryExpression, operator: token.text, left: left, right: this.relational() };\n      }\n      return left;\n    }\n\n    relational() {\n      let left = this.additive();\n      let token;\n      while ((token = this.expect('<', '>', '<=', '>='))) {\n        left = { type: AST.BinaryExpression, operator: token.text, left: left, right: this.additive() };\n      }\n      return left;\n    }\n\n    additive() {\n      let left = this.multiplicative();\n      let token;\n      while ((token = this.expect('+', '-'))) {\n        left = { type: AST.BinaryExpression, operator: token.text, left: left, right: this.multiplicative() };\n      }\n      return left;\n    }\n\n    multiplicative() {\n      let left = this.unary();\n      let token;\n      while ((token = this.expect('*', '/', '%'))) {\n        left = { type: AST.BinaryExpression, operator: token.text, left: left, right: this.unary() };\n      }\n      return left;\n    }\n\n    unary() {\n      let token;\n      if ((token = this.expect('+', '-', '!'))) {\n        return { type: AST.UnaryExpression, operator: token.text, prefix: true, argument: this.unary() };\n      } else {\n        return this.primary();\n      }\n    }\n\n    primary() {\n      let primary;\n      if (this.expect('(')) {\n        primary = this.filterChain();\n        this.consume(')');\n      } else if (this.expect('[')) {\n        primary = this.arrayDeclaration();\n      } else if (this.expect('{')) {\n        primary = this.object();\n      } else if (this.constants.hasOwnProperty(this.peek().text)) {\n        primary = copy(this.constants[this.consume().text]);\n      } else if (this.peek().identifier) {\n        primary = this.identifier();\n      } else if (this.peek().constant) {\n        primary = this.constant();\n      } else {\n        this.throwError('not a primary expression', this.peek());\n      }\n\n      let next;\n      while ((next = this.expect('(', '[', '.'))) {\n        if (next.text === '[') {\n          primary = { type: AST.MemberExpression, object: primary, property: this.expression(), computed: true };\n          this.consume(']');\n        } else if (next.text === '.') {\n          primary = { type: AST.MemberExpression, object: primary, property: this.identifier(), computed: false };\n        } else {\n          this.throwError('IMPOSSIBLE');\n        }\n      }\n      return primary;\n    }\n\n    filter(baseExpression) {\n      let args = [baseExpression];\n      let result = { type: AST.CallExpression, callee: this.identifier(), arguments: args, filter: true };\n\n      while (this.expect(':')) {\n        args.push(this.expression());\n      }\n\n      return result;\n    }\n\n    identifier() {\n      let token = this.consume();\n      if (!token.identifier) {\n        this.throwError('is not a valid identifier', token);\n      }\n      return { type: AST.Identifier, name: token.text };\n    }\n\n    constant() {\n      // TODO check that it is a constant\n      return { type: AST.Literal, value: this.consume().value };\n    }\n\n    arrayDeclaration() {\n      let elements = [];\n      if (this.peekToken().text !== ']') {\n        do {\n          if (this.peek(']')) {\n            // Support trailing commas\n            break;\n          }\n          elements.push(this.expression());\n        } while (this.expect(','));\n      }\n      this.consume(']');\n\n      return { type: AST.ArrayExpression, elements: elements };\n    }\n\n    object() {\n      let properties = [], property;\n      if (this.peekToken().text !== '}') {\n        do {\n          if (this.peek('}')) {\n            // Support trailing commas\n            break;\n          }\n          property = { type: AST.Property, kind: 'init' };\n          if (this.peek().constant) {\n            property.key = this.constant();\n          } else if (this.peek().identifier) {\n            property.key = this.identifier();\n          } else {\n            this.throwError('invalid key', this.peek());\n          }\n          this.consume(':');\n          property.value = this.expression();\n          properties.push(property);\n        } while (this.expect(','));\n      }\n      this.consume('}');\n\n      return { type: AST.ObjectExpression, properties: properties };\n    }\n\n    throwError(msg, token) {\n      throw Error(`Syntax Error: Token \\'${token.text}\\' ${msg} at column ${token.index + 1} of the expression [${this.text}] starting at [${this.text.substring(token.index)}].`);\n    }\n\n    consume(e1) {\n      if (this.tokens.length === 0) {\n        throw Error(`Unexpected end of expression: ${this.text}`);\n      }\n\n      let token = this.expect(e1);\n      if (!token) {\n        this.throwError('is unexpected, expecting [' + e1 + ']', this.peek());\n      }\n      return token;\n    }\n\n    peekToken() {\n      if (this.tokens.length === 0) {\n        throw Error(`Unexpected end of expression: ${this.text}`);\n      }\n      return this.tokens[0];\n    }\n\n    peek(e1, e2, e3, e4) {\n      return this.peekAhead(0, e1, e2, e3, e4);\n    }\n\n    peekAhead(i, e1, e2, e3, e4) {\n      if (this.tokens.length > i) {\n        let token = this.tokens[i];\n        let t = token.text;\n        if (t === e1 || t === e2 || t === e3 || t === e4 ||\n          (!e1 && !e2 && !e3 && !e4)) {\n          return token;\n        }\n      }\n      return false;\n    }\n\n    expect(e1, e2, e3, e4) {\n      let token = this.peek(e1, e2, e3, e4);\n      if (token) {\n        this.tokens.shift();\n        return token;\n      }\n      return false;\n    }\n  }\n\n  AST.ConditionalExpression = 'ConditionalExpression';\n  AST.LogicalExpression = 'LogicalExpression';\n  AST.BinaryExpression = 'BinaryExpression';\n  AST.UnaryExpression = 'UnaryExpression';\n  AST.CallExpression = 'CallExpression';\n  AST.MemberExpression = 'MemberExpression';\n  AST.Identifier = 'Identifier';\n  AST.Literal = 'Literal';\n  AST.ArrayExpression = 'ArrayExpression';\n  AST.Property = 'Property';\n  AST.ObjectExpression = 'ObjectExpression';\n\n  AST.PRECEDENCE = {\n    [AST.ConditionalExpression]: 1,\n    [AST.LogicalExpression]: 1,\n    [AST.BinaryExpression]: 2,\n    [AST.UnaryExpression]: 3,\n    [AST.CallExpression]: 4,\n    [AST.MemberExpression]: 5,\n    [AST.Identifier]: 6,\n    [AST.Literal]: 6,\n    [AST.ObjectExpression]: 6,\n    [AST.Property]: 6,\n    [AST.ArrayExpression]: 6,\n  };\n\n  AST.LOGICAL_EXPRESSION_PRECEDENCE = {\n    '||': 1,\n    '&&': 2,\n  };\n\n  AST.BINARY_EXPRESSION_PRECEDENCE = {\n    '==': 1,\n    '!=': 1,\n    '<': 2,\n    '<=': 2,\n    '>': 2,\n    '>=': 2,\n    '+': 3,\n    '-': 3,\n    '*': 4,\n    '/': 4,\n    '%': 4,\n  };\n\n  exports.AST = AST;\n\n  const parser__DEFAULT_OPTIONS = {};\n\n  class Parser {\n    constructor(astBuilder, options) {\n      this.astBuilder = astBuilder;\n      this.options = defaults(options, parser__DEFAULT_OPTIONS);\n    }\n\n    precedence(expr1, expr2) {\n      var prec = AST.PRECEDENCE;\n      if (prec[expr1.type] < prec[expr2.type]) {\n        return -1;\n      } else if (prec[expr1.type] > prec[expr2.type]) {\n        return +1;\n      } else if (expr1.type === AST.LogicalExpression || expr1.type === AST.BinaryExpression) {\n        let oprec = expr1.type === AST.LogicalExpression ? AST.LOGICAL_EXPRESSION_PRECEDENCE : AST.BINARY_EXPRESSION_PRECEDENCE;\n        if (oprec[expr1.operator] < oprec[expr2.operator]) {\n          return -1;\n        } else if (oprec[expr1.operator] > oprec[expr2.operator]) {\n          return +1;\n        }\n      }\n      return 0;\n    }\n\n    toString(ast, parent) {\n      let str = expr => this.toString(expr, ast);\n      if (parent && this.precedence(ast, parent) < 0) {\n        return `(${this.toString(ast)})`;\n      }\n      switch (ast.type) {\n        case AST.ConditionalExpression:\n          return `${str(ast.test)} ? ${str(ast.consequent)} : ${str(ast.alternate)}`;\n        case AST.LogicalExpression:\n          return `${str(ast.left)} ${ast.operator} ${str(ast.right)}`;\n        case AST.BinaryExpression:\n          return `${str(ast.left)} ${ast.operator} ${str(ast.right)}`;\n        case AST.UnaryExpression:\n          return `${ast.operator}${str(ast.argument)}`;\n        case AST.CallExpression:\n          let args = ast.arguments.slice(1)\n            .map(arg => arg.type === AST.CallExpression ? `:(${str(arg)})` : `:${str(arg)}`).join('');\n          return `${str(ast.arguments[0])}|${ast.callee.name}${args}`;\n        case AST.MemberExpression:\n          if (!ast.computed && ast.property.type === AST.Identifier) {\n            return `${str(ast.object)}.${ast.property.name}`;\n          }\n          return `${str(ast.object)}[${str(ast.property)}]`;\n        case AST.Identifier:\n          return ast.name;\n        case AST.Literal:\n          return ast.value === undefined ? 'undefined' : JSON.stringify(ast.value);\n        case AST.ArrayExpression:\n          return `[${ast.elements.map(expr => this.toString(expr)).join(', ')}]`;\n        case AST.ObjectExpression:\n          let properties = ast.properties.map(expr => {\n            if (expr.key.type === AST.Identifier || expr.key.type === AST.Literal) {\n              return `${this.toString(expr.key)}: ${this.toString(expr.value)}`;\n            } else {\n              this.throwError('IMPOSSIBLE');\n            }\n          });\n          return `{${properties.join(', ')}}`;\n      }\n    }\n\n    eval(ast, locals = {}, filters = {}) {\n      let e = expr => this.eval(expr, locals, filters);\n      try {\n        switch (ast.type) {\n          case AST.ConditionalExpression:\n            return e(ast.test) ? e(ast.consequent) : e(ast.alternate);\n          case AST.LogicalExpression:\n            switch (ast.operator) {\n              case '&&':\n                return e(ast.left) && e(ast.right);\n              case '||':\n                return e(ast.left) || e(ast.right);\n              default:\n                this.throwError('IMPOSSIBLE');\n            }\n            break;\n          case AST.BinaryExpression:\n            let left = e(ast.left);\n            let right = e(ast.right);\n            switch (ast.operator) {\n              case '==':\n                return left === right;\n              case '!=':\n                return left !== right;\n              case '<':\n                return left < right;\n              case '<=':\n                return left <= right;\n              case '>':\n                return left > right;\n              case '>=':\n                return left >= right;\n              case '+':\n                return left + right;\n              case '-':\n                return left - right;\n              case '*':\n                return left * right;\n              case '/':\n                return left / right;\n              case '%':\n                return left % right;\n              default:\n                this.throwError('IMPOSSIBLE');\n            }\n            break;\n          case AST.UnaryExpression:\n            switch (ast.operator) {\n              case '+':\n                return +e(ast.argument);\n              case '-':\n                return -e(ast.argument);\n              case '!':\n                return !e(ast.argument);\n              default:\n                this.throwError('IMPOSSIBLE');\n            }\n            break;\n          case AST.CallExpression:\n            if (ast.callee.type !== AST.Identifier) {\n              this.throwError('IMPOSSIBLE');\n            }\n            if (!(ast.callee.name in filters)) {\n              this.throwError(`Reference error: [${ast.callee.name}] is not a defined filter`);\n            }\n            let callee = filters[ast.callee.name];\n            let args = ast.arguments.map(e);\n            return callee.apply(null, args);\n          case AST.MemberExpression:\n            if (ast.property.type === AST.Identifier && !ast.computed) {\n              return e(ast.object)[ast.property.name];\n            }\n            return e(ast.object)[e(ast.property)];\n          case AST.Identifier:\n            if (!(ast.name in locals)) {\n              this.throwError(`Reference error: [${ast.name}] is not a defined variable`);\n            }\n            return locals[ast.name];\n          case AST.Literal:\n            return ast.value;\n          case AST.ArrayExpression:\n            return ast.elements.map(e);\n          case AST.ObjectExpression:\n            let res = {};\n            ast.properties.forEach(prop => {\n              if (prop.key.type === AST.Identifier) {\n                res[prop.key.name] = e(prop.value);\n              } else {\n                res[e(prop.key)] = e(prop.value);\n              }\n            });\n            return res;\n        }\n      } catch (err) {\n        if (err.bubble) {\n          throw err;\n        }\n        let info = (err.message || 'No info available');\n        this.throwError(`There was an error evaluating \\`${this.toString(ast)}\\` (${info})`, true);\n      }\n    }\n\n    throwError(msg, bubble = false) {\n      let err = Error(`Parse Error: ${msg}`);\n      err.bubble = bubble;\n      throw err;\n    }\n\n    parse(text) {\n      let ast = this.astBuilder.ast(text);\n      return (locals = {}, filters = {}) => this.eval(ast, locals, filters);\n    }\n  }\n\n  exports.Parser = Parser;\n\n  'use strict';\n\n}));\n"],"sourceRoot":"/source/"}