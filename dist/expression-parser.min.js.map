{"version":3,"sources":["expression-parser.min.js","/source/expression-parser.js"],"names":["_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","i","length","descriptor","protoProps","staticProps","prototype","global","factory","exports","module","define","amd","ExpressionParser","this","isDefined","isString","isBoolean","helpers__isNumber","isDate","toString","call","isFunction","isRegExp","copy","source","isArray","map","Date","getTime","dest","RegExp","match","lastIndex","hasOwnProperty","defaults","options","arguments","undefined","defaults_","keys","forEach","_AST$PRECEDENCE","OPERATORS","+","-","*","/","%","==","!=","<",">","<=",">=","&&","||","!","=","|","ESCAPE","n","f","r","t","v","'","\"","getPrototypeOf","Array","Lexer","text","index","tokens","ch","charAt","readString","isNumber","peek","readNumber","isIdent","readIdent","is","readBacktickIdent","push","isWhitespace","ch2","ch3","op1","op2","op3","token","operator","throwError","chars","indexOf","num","error","start","end","colStr","substring","Error","number","toLowerCase","peekCh","isExpOperator","constant","Number","string","rawString","escape","hex","String","fromCharCode","parseInt","rep","rawText","identifier","backtick","slice","quote","_ast__DEFAULT_OPTIONS","AST","lexer","constants","true","type","Literal","false","null","lex","filterChain","expect","left","expression","filter","ternary","test","logicalOR","alternate","consequent","consume","ConditionalExpression","logicalAND","LogicalExpression","right","equality","relational","BinaryExpression","additive","multiplicative","unary","UnaryExpression","prefix","argument","primary","arrayDeclaration","object","next","MemberExpression","property","computed","baseExpression","args","result","CallExpression","callee","Identifier","name","elements","peekToken","ArrayExpression","properties","Property","kind","ObjectExpression","msg","e1","e2","e3","e4","peekAhead","shift","PRECEDENCE","LOGICAL_EXPRESSION_PRECEDENCE","BINARY_EXPRESSION_PRECEDENCE","parser__DEFAULT_OPTIONS","LexerClass","ASTBuilderClass","Parser","astBuilder","expr1","expr2","prec","oprec","ast","parent","_this","str","expr","precedence","arg","join","JSON","stringify","_this2","locals","filters","e","eval","apply","res","prop","err","bubble","info","message","_this3"],"mappings":"AAEA,QAASA,iBAAgBC,EAAKC,EAAKC,GAAiK,MAApJD,KAAOD,GAAOG,OAAOC,eAAeJ,EAAKC,GAAOC,MAAOA,EAAOG,YAAY,EAAMC,cAAc,EAAMC,UAAU,IAAkBP,EAAIC,GAAOC,EAAgBF,EAE3M,QAASQ,iBAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCAJhH,GAAIC,cAAe,WAAe,QAASC,GAAiBC,EAAQC,GAAS,IAAK,GAAIC,GAAI,EAAGA,EAAID,EAAME,OAAQD,IAAK,CAAE,GAAIE,GAAaH,EAAMC,EAAIE,GAAWb,WAAaa,EAAWb,aAAc,EAAOa,EAAWZ,cAAe,EAAU,SAAWY,KAAYA,EAAWX,UAAW,GAAMJ,OAAOC,eAAeU,EAAQI,EAAWjB,IAAKiB,IAAiB,MAAO,UAAUR,EAAaS,EAAYC,GAAiJ,MAA9HD,IAAYN,EAAiBH,EAAYW,UAAWF,GAAiBC,GAAaP,EAAiBH,EAAaU,GAAqBV,OCAhiB,SAAUY,EAAQC,GACE,gBAAZC,UAA0C,mBAAXC,QAAyBF,EAAQC,SACrD,kBAAXE,SAAyBA,OAAOC,IAAMD,QAAQ,WAAYH,GACjEA,EAASD,EAAOM,sBAChBC,KAAM,SAAUL,GAAW,YAqC3B,SAASM,GAAU5B,GACjB,MAAwB,mBAAVA,GAOhB,QAAS6B,GAAS7B,GAChB,MAAwB,gBAAVA,GAGhB,QAAS8B,GAAU9B,GACjB,MAAwB,iBAAVA,GAGhB,QAAS+B,GAAkB/B,GACzB,MAAwB,gBAAVA,GAGhB,QAASgC,GAAOhC,GACd,MAAgC,kBAAzBiC,SAASC,KAAKlC,GAKvB,QAASmC,GAAWnC,GAClB,MAAwB,kBAAVA,GAGhB,QAASoC,GAASpC,GAChB,MAAgC,oBAAzBiC,SAASC,KAAKlC,GAGvB,QAASqC,GAAKC,GACZ,GAAIC,EAAQD,GACV,MAAOA,GAAOE,IAAIH,EACb,IAAIL,EAAOM,GAChB,MAAO,IAAIG,MAAKH,EAAOI,UAClB,IAAIN,EAASE,GAAS,CAC3B,GAAIK,GAAO,GAAIC,QAAON,EAAOA,OAAQA,EAAOL,WAAWY,MAAM,WAAW,GAExE,OADAF,GAAKG,UAAYR,EAAOQ,UACjBH,EACF,GAAIZ,EAAkBO,IAAWT,EAASS,IAAWR,EAAUQ,IAAWH,EAAWG,GAC1F,MAAOA,EAEP,IAAIK,KACJ,KAAK,GAAI5C,KAAOuC,GACVA,EAAOS,eAAehD,KACxB4C,EAAK5C,GAAOsC,EAAKC,EAAOvC,IAG5B,OAAO4C,GAIX,QAASK,KDQP,GCRgBC,GAAOC,UAAAnC,QAAA,GAAAoC,SAAAD,UAAA,MAAKA,UAAA,GAAEE,EAASF,UAAAnC,QAAA,GAAAoC,SAAAD,UAAA,MAAKA,UAAA,EAM5C,OALAjD,QAAOoD,KAAKD,GAAWE,QAAQ,SAAAvD,GACD,mBAAjBkD,GAAQlD,KACjBkD,EAAQlD,GAAOsC,EAAKe,EAAUrD,OAG3BkD,ED5FT,GAAIM,GCLEC,GACJC,KAAK,EACLC,KAAK,EACLC,KAAK,EACLC,KAAK,EACLC,KAAK,EACLC,MAAM,EACNC,MAAM,EACNC,KAAK,EACLC,KAAK,EACLC,MAAM,EACNC,MAAM,EACNC,MAAM,EACNC,MAAM,EACNC,KAAK,EACLC,KAAK,EACLC,KAAK,GAGDC,GACJC,EAAK,KACLC,EAAK,KACLC,EAAK,KACLC,EAAK,IACLC,EAAK,IACLC,IAAM,IACNC,IAAK,KAiCHzC,GA9BiBtC,OAAOgF,eA8BdC,MAAM3C,SAyCd4C,EAAK,WAEE,QAFPA,GAEQlC,GDUV3C,gBAAgBqB,KCZdwD,GAGFxD,KAAKsB,QAAUA,EDkOjB,MApNAvC,cCjBIyE,IDkBFpF,IAAK,MACLC,MCbC,SAACoF,GAKF,IAJAzD,KAAKyD,KAAOA,EACZzD,KAAK0D,MAAQ,EACb1D,KAAK2D,UAEE3D,KAAK0D,MAAQ1D,KAAKyD,KAAKrE,QAAQ,CACpC,GAAIwE,GAAK5D,KAAKyD,KAAKI,OAAO7D,KAAK0D,MAC/B,IAAW,MAAPE,GAAqB,MAAPA,EAChB5D,KAAK8D,WAAWF,OACX,IAAI5D,KAAK+D,SAASH,IAAc,MAAPA,GAAc5D,KAAK+D,SAAS/D,KAAKgE,QAC/DhE,KAAKiE,iBACA,IAAIjE,KAAKkE,QAAQN,GACtB5D,KAAKmE,gBACA,IAAInE,KAAKoE,GAAGR,EAAI,KACrB5D,KAAKqE,wBACA,IAAIrE,KAAKoE,GAAGR,EAAI,eACrB5D,KAAK2D,OAAOW,MAAOZ,MAAO1D,KAAK0D,MAAOD,KAAMG,IAC5C5D,KAAK0D,YACA,IAAI1D,KAAKuE,aAAaX,GAC3B5D,KAAK0D,YACA,CACL,GAAIc,GAAMZ,EAAK5D,KAAKgE,OAChBS,EAAMD,EAAMxE,KAAKgE,KAAK,GACtBU,EAAM7C,EAAU+B,GAChBe,EAAM9C,EAAU2C,GAChBI,EAAM/C,EAAU4C,EACpB,IAAIC,GAAOC,GAAOC,EAAK,CACrB,GAAIC,GAAQD,EAAMH,EAAOE,EAAMH,EAAMZ,CACrC5D,MAAK2D,OAAOW,MAAOZ,MAAO1D,KAAK0D,MAAOD,KAAMoB,EAAOC,UAAU,IAC7D9E,KAAK0D,OAASmB,EAAMzF,WAEpBY,MAAK+E,WAAW,4BAA6B/E,KAAK0D,MAAO1D,KAAK0D,MAAQ,IAI5E,MAAO1D,MAAK2D,UDgBZvF,IAAK,KACLC,MCdA,SAACuF,EAAIoB,GACL,MAA6B,KAAtBA,EAAMC,QAAQrB,MDiBrBxF,IAAK,OACLC,MCfE,SAACc,GACH,GAAI+F,GAAM/F,GAAK,CACf,OAAQa,MAAK0D,MAAQwB,EAAMlF,KAAKyD,KAAKrE,OAAUY,KAAKyD,KAAKI,OAAO7D,KAAK0D,MAAQwB,IAAO,KDkBpF9G,IAAK,WACLC,MChBM,SAACuF,GACP,MAAeA,IAAR,KAAoB,KAANA,GAA4B,gBAAPA,MDmB1CxF,IAAK,eACLC,MCjBU,SAACuF,GAEX,MAAe,MAAPA,GAAqB,OAAPA,GAAsB,MAAPA,GAC9B,OAAPA,GAAsB,MAAPA,GAAsB,MAAPA,KDmB9BxF,IAAK,UACLC,MCjBK,SAACuF,GACN,MAAeA,IAAP,KAAmB,KAANA,GACdA,GAAP,KAAmB,KAANA,GACb,MAAQA,GAAa,MAAPA,KDkBdxF,IAAK,gBACLC,MChBW,SAACuF,GACZ,MAAe,MAAPA,GAAqB,MAAPA,GAAc5D,KAAK+D,SAASH,MDmBlDxF,IAAK,aACLC,MCjBQ,SAAC8G,EAAOC,EAAOC,GACvBA,EAAMA,GAAOrF,KAAK0D,KAClB,IAAI4B,GAAUrF,EAAUmF,GACpB,KAAOA,EAAQ,IAAMpF,KAAK0D,MAAQ,KAAO1D,KAAKyD,KAAK8B,UAAUH,EAAOC,GAAO,IAC3E,IAAMA,CACV,MAAMG,OAAK,gBAAiBL,EAAK,aAAaG,EAAM,mBAAmBtF,KAAKyD,KAAI,SDkBhFrF,IAAK,aACLC,MChBQ,WAGR,IAFA,GAAIoH,GAAS,GACTL,EAAQpF,KAAK0D,MACV1D,KAAK0D,MAAQ1D,KAAKyD,KAAKrE,QAAQ,CACpC,GAAIwE,GAAK5D,KAAKyD,KAAKI,OAAO7D,KAAK0D,OAAOgC,aACtC,IAAW,MAAP9B,GAAc5D,KAAK+D,SAASH,GAC9B6B,GAAU7B,MACL,CACL,GAAI+B,GAAS3F,KAAKgE,MAClB,IAAW,MAAPJ,GAAc5D,KAAK4F,cAAcD,GACnCF,GAAU7B,MACL,IAAI5D,KAAK4F,cAAchC,IAC5B+B,GAAU3F,KAAK+D,SAAS4B,IACa,MAArCF,EAAO5B,OAAO4B,EAAOrG,OAAS,GAC9BqG,GAAU7B,MACL,CAAA,IAAI5D,KAAK4F,cAAchC,IAC1B+B,GAAW3F,KAAK+D,SAAS4B,IACU,MAArCF,EAAO5B,OAAO4B,EAAOrG,OAAS,GAG9B,KAFAY,MAAK+E,WAAW,qBAKpB/E,KAAK0D,QAEP1D,KAAK2D,OAAOW,MACVZ,MAAO0B,EACP3B,KAAMgC,EACNI,UAAU,EACVxH,MAAOyH,OAAOL,QDgBhBrH,IAAK,oBACLC,MCbe,WACf,GAAI+G,GAAQpF,KAAK0D,KACjB1D,MAAK0D,OAIL,KAHA,GAAIqC,GAAS,GACTC,EAAY,IACZC,GAAS,EACNjG,KAAK0D,MAAQ1D,KAAKyD,KAAKrE,QAAQ,CACpC,GAAIwE,GAAK5D,KAAKyD,KAAKI,OAAO7D,KAAK0D,MAE/B,IADAsC,GAAapC,EACTqC,EAAQ,CACV,GAAW,MAAPrC,EAAY,CACd,GAAIsC,GAAMlG,KAAKyD,KAAK8B,UAAUvF,KAAK0D,MAAQ,EAAG1D,KAAK0D,MAAQ,EACtDwC,GAAIhF,MAAM,gBACblB,KAAK+E,WAAW,8BAAgCmB,EAAM,KAExDlG,KAAK0D,OAAS,EACdqC,GAAUI,OAAOC,aAAaC,SAASH,EAAK,SACvC,CACL,GAAII,GAAMxD,EAAOc,EACjBmC,IAAmBO,GAAO1C,EAE5BqC,GAAS,MACJ,IAAW,OAAPrC,EACTqC,GAAS,MACJ,CAAA,GAAW,MAAPrC,EAST,MARA5D,MAAK0D,YACL1D,MAAK2D,OAAOW,MACVZ,MAAO0B,EACP3B,KAAMsC,EACNQ,QAASP,EACTQ,YAAY,EACZC,UAAU,GAIZV,IAAUnC,EAEZ5D,KAAK0D,QAEP1D,KAAK+E,WAAW,mCAAoCK,MDgBpDhH,IAAK,YACLC,MCdO,WAEP,IADA,GAAI+G,GAAQpF,KAAK0D,MACV1D,KAAK0D,MAAQ1D,KAAKyD,KAAKrE,QAAQ,CACpC,GAAIwE,GAAK5D,KAAKyD,KAAKI,OAAO7D,KAAK0D,MAC/B,KAAM1D,KAAKkE,QAAQN,KAAO5D,KAAK+D,SAASH,GACtC,KAEF5D,MAAK0D,QAEP1D,KAAK2D,OAAOW,MACVZ,MAAO0B,EACP3B,KAAMzD,KAAKyD,KAAKiD,MAAMtB,EAAOpF,KAAK0D,OAClC8C,YAAY,ODkBdpI,IAAK,aACLC,MCfQ,SAACsI,GACT,GAAIvB,GAAQpF,KAAK0D,KACjB1D,MAAK0D,OAIL,KAHA,GAAIqC,GAAS,GACTC,EAAYW,EACZV,GAAS,EACNjG,KAAK0D,MAAQ1D,KAAKyD,KAAKrE,QAAQ,CACpC,GAAIwE,GAAK5D,KAAKyD,KAAKI,OAAO7D,KAAK0D,MAE/B,IADAsC,GAAapC,EACTqC,EAAQ,CACV,GAAW,MAAPrC,EAAY,CACd,GAAIsC,GAAMlG,KAAKyD,KAAK8B,UAAUvF,KAAK0D,MAAQ,EAAG1D,KAAK0D,MAAQ,EACtDwC,GAAIhF,MAAM,gBACblB,KAAK+E,WAAW,8BAAgCmB,EAAM,KAExDlG,KAAK0D,OAAS,EACdqC,GAAUI,OAAOC,aAAaC,SAASH,EAAK,SACvC,CACL,GAAII,GAAMxD,EAAOc,EACjBmC,IAAmBO,GAAO1C,EAE5BqC,GAAS,MACJ,IAAW,OAAPrC,EACTqC,GAAS,MACJ,CAAA,GAAIrC,IAAO+C,EAQhB,MAPA3G,MAAK0D,YACL1D,MAAK2D,OAAOW,MACVZ,MAAO0B,EACP3B,KAAMuC,EACNH,UAAU,EACVxH,MAAO0H,GAITA,IAAUnC,EAEZ5D,KAAK0D,QAEP1D,KAAK+E,WAAW,qBAAsBK,OAlNpC5B,IAsNN7D,GAAQ6D,MAAQA,CAEhB,IAAMoD,MAEAC,EAAG,WAEI,QAFPA,GAEQC,EAAOxF,GDkBjB3C,gBAAgBqB,KCpBd6G,GAGF7G,KAAK8G,MAAQA,EACb9G,KAAKsB,QAAUD,EAASC,EAASsF,GACjC5G,KAAK+G,WACHC,QAAUC,KAAMJ,EAAIK,QAAS7I,OAAO,GACpC8I,SAAWF,KAAMJ,EAAIK,QAAS7I,OAAO,GACrC+I,QAAUH,KAAMJ,EAAIK,QAAS7I,MAAO,MACpCmD,WAAeyF,KAAMJ,EAAIK,QAAS7I,MAAOmD,SD0S7C,MAnRAzC,cChCI8H,IDiCFzI,IAAK,MACLC,MCrBC,SAACoF,GACFzD,KAAKyD,KAAOA,EACZzD,KAAK2D,OAAS3D,KAAK8G,MAAMO,IAAI5D,EAE7B,IAAIpF,GAAQ2B,KAAKsH,aAQjB,OAPItH,MAAKgE,KAAK,MAEZhE,KAAKuH,OAAO,KAEa,IAAvBvH,KAAK2D,OAAOvE,QACdY,KAAK+E,WAAW,yBAA0B/E,KAAK2D,OAAO,IAEjDtF,KDwBPD,IAAK,cACLC,MCtBS,WAGT,IAFA,GAAImJ,GAAOxH,KAAKyH,aACZ5C,EAAKrD,OACDqD,EAAQ7E,KAAKuH,OAAO,MAC1BC,EAAOxH,KAAK0H,OAAOF,EAErB,OAAOA,MDyBPpJ,IAAK,aACLC,MCvBQ,WACR,MAAO2B,MAAK2H,aD0BZvJ,IAAK,UACLC,MCxBK,WACL,GAAIuJ,GAAO5H,KAAK6H,YACZC,EAAStG,OACTuG,EAAUvG,MACd,OAAIxB,MAAKuH,OAAO,OACdQ,EAAa/H,KAAKyH,aACdzH,KAAKgI,QAAQ,OACfF,EAAY9H,KAAKyH,cACRR,KAAMJ,EAAIoB,sBAAuBL,KAAMA,EAAMG,WAAYA,EAAYD,UAAWA,IAGtFF,KD2BPxJ,IAAK,YACLC,MCzBO,WAEP,IADA,GAAImJ,GAAOxH,KAAKkI,aACTlI,KAAKuH,OAAO,OACjBC,GAASP,KAAMJ,EAAIsB,kBAAmBrD,SAAU,KAAM0C,KAAMA,EAAMY,MAAOpI,KAAKkI,aAEhF,OAAOV,MD4BPpJ,IAAK,aACLC,MC1BQ,WAER,IADA,GAAImJ,GAAOxH,KAAKqI,WACTrI,KAAKuH,OAAO,OACjBC,GAASP,KAAMJ,EAAIsB,kBAAmBrD,SAAU,KAAM0C,KAAMA,EAAMY,MAAOpI,KAAKqI,WAEhF,OAAOb,MD6BPpJ,IAAK,WACLC,MC3BM,WAGN,IAFA,GAAImJ,GAAOxH,KAAKsI,aACZzD,EAAKrD,OACDqD,EAAQ7E,KAAKuH,OAAO,KAAM,OAChCC,GAASP,KAAMJ,EAAI0B,iBAAkBzD,SAAUD,EAAMpB,KAAM+D,KAAMA,EAAMY,MAAOpI,KAAKsI,aAErF,OAAOd,MD8BPpJ,IAAK,aACLC,MC5BQ,WAGR,IAFA,GAAImJ,GAAOxH,KAAKwI,WACZ3D,EAAKrD,OACDqD,EAAQ7E,KAAKuH,OAAO,IAAK,IAAK,KAAM,OAC1CC,GAASP,KAAMJ,EAAI0B,iBAAkBzD,SAAUD,EAAMpB,KAAM+D,KAAMA,EAAMY,MAAOpI,KAAKwI,WAErF,OAAOhB,MD+BPpJ,IAAK,WACLC,MC7BM,WAGN,IAFA,GAAImJ,GAAOxH,KAAKyI,iBACZ5D,EAAKrD,OACDqD,EAAQ7E,KAAKuH,OAAO,IAAK,MAC/BC,GAASP,KAAMJ,EAAI0B,iBAAkBzD,SAAUD,EAAMpB,KAAM+D,KAAMA,EAAMY,MAAOpI,KAAKyI,iBAErF,OAAOjB,MDgCPpJ,IAAK,iBACLC,MC9BY,WAGZ,IAFA,GAAImJ,GAAOxH,KAAK0I,QACZ7D,EAAKrD,OACDqD,EAAQ7E,KAAKuH,OAAO,IAAK,IAAK,MACpCC,GAASP,KAAMJ,EAAI0B,iBAAkBzD,SAAUD,EAAMpB,KAAM+D,KAAMA,EAAMY,MAAOpI,KAAK0I,QAErF,OAAOlB,MDiCPpJ,IAAK,QACLC,MC/BG,WACH,GAAIwG,GAAKrD,MACT,QAAKqD,EAAQ7E,KAAKuH,OAAO,IAAK,IAAK,OACxBN,KAAMJ,EAAI8B,gBAAiB7D,SAAUD,EAAMpB,KAAMmF,QAAQ,EAAMC,SAAU7I,KAAK0I,SAEhF1I,KAAK8I,aDmCd1K,IAAK,UACLC,MChCK,QAAAyK,KACL,GAAIA,GAAOtH,MACPxB,MAAKuH,OAAO,MACduB,EAAU9I,KAAKsH,cACftH,KAAKgI,QAAQ,MACJhI,KAAKuH,OAAO,KACrBuB,EAAU9I,KAAK+I,mBACN/I,KAAKuH,OAAO,KACrBuB,EAAU9I,KAAKgJ,SACNhJ,KAAK+G,UAAU3F,eAAepB,KAAKgE,OAAOP,MACnDqF,EAAUpI,EAAKV,KAAK+G,UAAU/G,KAAKgI,UAAUvE,OACpCzD,KAAKgE,OAAOwC,WACrBsC,EAAU9I,KAAKwG,aACNxG,KAAKgE,OAAO6B,SACrBiD,EAAU9I,KAAK6F,WAEf7F,KAAK+E,WAAW,2BAA4B/E,KAAKgE,OAInD,KADA,GAAIiF,GAAIzH,OACAyH,EAAOjJ,KAAKuH,OAAO,IAAK,IAAK,MACjB,MAAd0B,EAAKxF,MACPqF,GAAY7B,KAAMJ,EAAIqC,iBAAkBF,OAAQF,EAASK,SAAUnJ,KAAKyH,aAAc2B,UAAU,GAChGpJ,KAAKgI,QAAQ,MACU,MAAdiB,EAAKxF,KACdqF,GAAY7B,KAAMJ,EAAIqC,iBAAkBF,OAAQF,EAASK,SAAUnJ,KAAKwG,aAAc4C,UAAU,GAEhGpJ,KAAK+E,WAAW,aAGpB,OAAO+D,MDmCP1K,IAAK,SACLC,MCjCI,SAACgL,GAIL,IAHA,GAAIC,IAAQD,GACRE,GAAWtC,KAAMJ,EAAI2C,eAAgBC,OAAQzJ,KAAKwG,aAAcjF,UAAW+H,EAAM5B,QAAQ,GAEtF1H,KAAKuH,OAAO,MACjB+B,EAAKhF,KAAKtE,KAAKyH,aAGjB,OAAO8B,MDoCPnL,IAAK,aACLC,MClCQ,WACR,GAAIwG,GAAQ7E,KAAKgI,SAIjB,OAHKnD,GAAM2B,YACTxG,KAAK+E,WAAW,4BAA6BF,IAEtCoC,KAAMJ,EAAI6C,WAAYC,KAAM9E,EAAMpB,KAAMgD,WAAY5B,EAAM4B,aDqCnErI,IAAK,WACLC,MCnCM,WAEN,OAAS4I,KAAMJ,EAAIK,QAAS7I,MAAO2B,KAAKgI,UAAU3J,UDsClDD,IAAK,mBACLC,MCpCc,WACd,GAAIuL,KACJ,IAA8B,MAA1B5J,KAAK6J,YAAYpG,KACnB,EAAG,CACD,GAAIzD,KAAKgE,KAAK,KAEZ,KAEF4F,GAAStF,KAAKtE,KAAKyH,oBACZzH,KAAKuH,OAAO,KAIvB,OAFAvH,MAAKgI,QAAQ,MAEJf,KAAMJ,EAAIiD,gBAAiBF,SAAUA,MDuC9CxL,IAAK,SACLC,MCrCI,WACJ,GAAI0L,MAAiBZ,EAAQ3H,MAC7B,IAA8B,MAA1BxB,KAAK6J,YAAYpG,KACnB,EAAG,CACD,GAAIzD,KAAKgE,KAAK,KAEZ,KAEFmF,IAAalC,KAAMJ,EAAImD,SAAUC,KAAM,QACnCjK,KAAKgE,OAAO6B,SACdsD,EAAS/K,IAAM4B,KAAK6F,WACX7F,KAAKgE,OAAOwC,WACrB2C,EAAS/K,IAAM4B,KAAKwG,aAEpBxG,KAAK+E,WAAW,cAAe/E,KAAKgE,QAEtChE,KAAKgI,QAAQ,KACbmB,EAAS9K,MAAQ2B,KAAKyH,aACtBsC,EAAWzF,KAAK6E,SACTnJ,KAAKuH,OAAO,KAIvB,OAFAvH,MAAKgI,QAAQ,MAEJf,KAAMJ,EAAIqD,iBAAkBH,WAAYA,MDyCjD3L,IAAK,aACLC,MCvCQ,SAAC8L,EAAKtF,GACd,KAAMW,OAAK,wBAA0BX,EAAMpB,KAAI,KAAM0G,EAAG,eAActF,EAAMnB,MAAQ,GAAC,uBAAuB1D,KAAKyD,KAAI,kBAAkBzD,KAAKyD,KAAK8B,UAAUV,EAAMnB,OAAM,SD0CvKtF,IAAK,UACLC,MCxCK,SAAC+L,GACN,GAA2B,IAAvBpK,KAAK2D,OAAOvE,OACd,KAAMoG,OAAK,iCAAkCxF,KAAKyD,KAGpD,IAAIoB,GAAQ7E,KAAKuH,OAAO6C,EAIxB,OAHKvF,IACH7E,KAAK+E,WAAW,6BAA+BqF,EAAK,IAAKpK,KAAKgE,QAEzDa,KD2CPzG,IAAK,YACLC,MCzCO,WACP,GAA2B,IAAvB2B,KAAK2D,OAAOvE,OACd,KAAMoG,OAAK,iCAAkCxF,KAAKyD,KAEpD,OAAOzD,MAAK2D,OAAO,MD4CnBvF,IAAK,OACLC,MC1CE,SAAC+L,EAAIC,EAAIC,EAAIC,GACf,MAAOvK,MAAKwK,UAAU,EAAGJ,EAAIC,EAAIC,EAAIC,MD6CrCnM,IAAK,YACLC,MC3CO,SAACc,EAAGiL,EAAIC,EAAIC,EAAIC,GACvB,GAAIvK,KAAK2D,OAAOvE,OAASD,EAAG,CAC1B,GAAI0F,GAAQ7E,KAAK2D,OAAOxE,GACpB+D,EAAI2B,EAAMpB,IACd,IAAIP,IAAMkH,GAAMlH,IAAMmH,GAAMnH,IAAMoH,GAAMpH,IAAMqH,IAC1CH,IAAOC,IAAOC,IAAOC,EACvB,MAAO1F,GAGX,OAAO,KD6CPzG,IAAK,SACLC,MC3CI,SAAC+L,EAAIC,EAAIC,EAAIC,GACjB,GAAI1F,GAAQ7E,KAAKgE,KAAKoG,EAAIC,EAAIC,EAAIC,EAClC,OAAI1F,IACF7E,KAAK2D,OAAO8G,QACL5F,IAEF,MApQLgC,IAwQNA,GAAIoB,sBAAwB,wBAC5BpB,EAAIsB,kBAAoB,oBACxBtB,EAAI0B,iBAAmB,mBACvB1B,EAAI8B,gBAAkB,kBACtB9B,EAAI2C,eAAiB,iBACrB3C,EAAIqC,iBAAmB,mBACvBrC,EAAI6C,WAAa,aACjB7C,EAAIK,QAAU,UACdL,EAAIiD,gBAAkB,kBACtBjD,EAAImD,SAAW,WACfnD,EAAIqD,iBAAmB,mBAEvBrD,EAAI6D,YAAU9I,KAAA1D,gBAAA0D,EACXiF,EAAIoB,sBAAwB,GAAC/J,gBAAA0D,EAC7BiF,EAAIsB,kBAAoB,GAACjK,gBAAA0D,EACzBiF,EAAI0B,iBAAmB,GAACrK,gBAAA0D,EACxBiF,EAAI8B,gBAAkB,GAACzK,gBAAA0D,EACvBiF,EAAI2C,eAAiB,GAACtL,gBAAA0D,EACtBiF,EAAIqC,iBAAmB,GAAChL,gBAAA0D,EACxBiF,EAAI6C,WAAa,GAACxL,gBAAA0D,EAClBiF,EAAIK,QAAU,GAAChJ,gBAAA0D,EACfiF,EAAIqD,iBAAmB,GAAChM,gBAAA0D,EACxBiF,EAAImD,SAAW,GAAC9L,gBAAA0D,EAChBiF,EAAIiD,gBAAkB,GAAClI,GAG1BiF,EAAI8D,+BACFjI,KAAM,EACND,KAAM,GAGRoE,EAAI+D,8BACFzI,KAAM,EACNC,KAAM,EACNC,IAAK,EACLE,KAAM,EACND,IAAK,EACLE,KAAM,EACNV,IAAK,EACLC,IAAK,EACLC,IAAK,EACLC,IAAK,EACLC,IAAK,GAGPvC,EAAQkH,IAAMA,CAEd,IAAMgE,IACJC,WAAYtH,EACZuH,gBAAiBlE,GAGbmE,EAAM,WACC,QADPA,GACQ1J,GDmCV3C,gBAAgBqB,KCpCdgL,GAEFhL,KAAKsB,QAAUD,EAASC,EAASuJ,EACjC,IAAI/D,GAAQ,GAAI9G,MAAKsB,QAAQwJ,UAC7B9K,MAAKiL,WAAa,GAAIjL,MAAKsB,QAAQyJ,gBAAgBjE,GD+OrD,MAxMA/H,cC3CIiM,ID4CF5M,IAAK,aACLC,MCtCQ,SAAC6M,EAAOC,GAChB,GAAIC,GAAOvE,EAAI6D,UACf,IAAIU,EAAKF,EAAMjE,MAAQmE,EAAKD,EAAMlE,MAChC,MAAO,EACF,IAAImE,EAAKF,EAAMjE,MAAQmE,EAAKD,EAAMlE,MACvC,MAAO,EACF,IAAIiE,EAAMjE,OAASJ,EAAIsB,mBAAqB+C,EAAMjE,OAASJ,EAAI0B,iBAAkB,CACtF,GAAI8C,GAAQH,EAAMjE,OAASJ,EAAIsB,kBAAoBtB,EAAI8D,8BAAgC9D,EAAI+D,4BAC3F,IAAIS,EAAMH,EAAMpG,UAAYuG,EAAMF,EAAMrG,UACtC,MAAO,EACF,IAAIuG,EAAMH,EAAMpG,UAAYuG,EAAMF,EAAMrG,UAC7C,MAAO,GAGX,MAAO,MDyCP1G,IAAK,WACLC,MCvCM,SAACiN,EAAKC,GDwCV,GAAIC,GAAQxL,KCvCVyL,EAAM,SAAAC,GD0CN,MC1CcF,GAAKlL,SAASoL,EAAMJ,GACtC,IAAIC,GAAUvL,KAAK2L,WAAWL,EAAKC,GAAU,EAC3C,MAAA,IAAWvL,KAAKM,SAASgL,GAAI,GAE/B,QAAQA,EAAIrE,MACV,IAAKJ,GAAIoB,sBACP,MAAUwD,GAAIH,EAAI1D,MAAK,MAAM6D,EAAIH,EAAIvD,YAAW,MAAM0D,EAAIH,EAAIxD,UAChE,KAAKjB,GAAIsB,kBACP,MAAUsD,GAAIH,EAAI9D,MAAK,IAAI8D,EAAIxG,SAAQ,IAAI2G,EAAIH,EAAIlD,MACrD,KAAKvB,GAAI0B,iBACP,MAAUkD,GAAIH,EAAI9D,MAAK,IAAI8D,EAAIxG,SAAQ,IAAI2G,EAAIH,EAAIlD,MACrD,KAAKvB,GAAI8B,gBACP,MAAA,GAAU2C,EAAIxG,SAAW2G,EAAIH,EAAIzC,SACnC,KAAKhC,GAAI2C,eACP,GAAIF,GAAOgC,EAAI/J,UAAUmF,MAAM,GAC5B7F,IAAI,SAAA+K,GD2CH,MC3CUA,GAAI3E,OAASJ,EAAI2C,eAAc,KAAQiC,EAAIG,GAAI,IAAA,IAAUH,EAAIG,KAAQC,KAAK,GACxF,OAAUJ,GAAIH,EAAI/J,UAAU,IAAG,IAAI+J,EAAI7B,OAAOE,KAAOL,CACvD,KAAKzC,GAAIqC,iBACP,MAAKoC,GAAIlC,UAAYkC,EAAInC,SAASlC,OAASJ,EAAI6C,WAGrC+B,EAAIH,EAAItC,QAAO,IAAIyC,EAAIH,EAAInC,UAAS,IAFlCsC,EAAIH,EAAItC,QAAO,KAAIsC,EAAInC,SAAS1C,SAAW,IAAM6E,EAAInC,SAASQ,KAAO,IAAM2B,EAAInC,SAASQ,KAGtG,KAAK9C,GAAI6C,WACP,MAAO4B,GAAI3B,IACb,KAAK9C,GAAIK,QACP,MAAqB1F,UAAd8J,EAAIjN,MAAsB,YAAcyN,KAAKC,UAAUT,EAAIjN,MACpE,KAAKwI,GAAIiD,gBACP,MAAA,IAAWwB,EAAI1B,SAAS/I,IAAI,SAAA6K,GD6CxB,MC7CgCF,GAAKlL,SAASoL,KAAOG,KAAK,MAAK,GACrE,KAAKhF,GAAIqD,iBACP,GAAIH,GAAauB,EAAIvB,WAAWlJ,IAAI,SAAA6K,GAClC,MAAIA,GAAKtN,IAAI6I,OAASJ,EAAI6C,YAAcgC,EAAKtN,IAAI6I,OAASJ,EAAIK,QAClDsE,EAAKlL,SAASoL,EAAKtN,KAAI,KAAKoN,EAAKlL,SAASoL,EAAKrN,WAEzDmN,GAAKzG,WAAW,eAGpB,OAAA,IAAWgF,EAAW8B,KAAK,MAAK,QDkDpCzN,IAAK,OACLC,MC/CE,SAACiN,GDgDD,GAAIU,GAAShM,KChDPiM,EAAM1K,UAAAnC,QAAA,GAAAoC,SAAAD,UAAA,MAAKA,UAAA,GAAE2K,EAAO3K,UAAAnC,QAAA,GAAAoC,SAAAD,UAAA,MAAKA,UAAA,GAC7B4K,EAAI,SAAAT,GDqDJ,MCrDYM,GAAKI,KAAKV,EAAMO,EAAQC,GACxC,KACE,OAAQZ,EAAIrE,MACV,IAAKJ,GAAIoB,sBACP,MAAqBkE,GAAdA,EAAEb,EAAI1D,MAAU0D,EAAIvD,WAAgBuD,EAAIxD,UACjD,KAAKjB,GAAIsB,kBACP,OAAQmD,EAAIxG,UACV,IAAK,KACH,MAAOqH,GAAEb,EAAI9D,OAAS2E,EAAEb,EAAIlD,MAC9B,KAAK,KACH,MAAO+D,GAAEb,EAAI9D,OAAS2E,EAAEb,EAAIlD,MAC9B,SACEpI,KAAK+E,WAAW,cAEpB,KACF,KAAK8B,GAAI0B,iBACP,GAAIf,GAAO2E,EAAEb,EAAI9D,MACbY,EAAQ+D,EAAEb,EAAIlD,MAClB,QAAQkD,EAAIxG,UACV,IAAK,KACH,MAAO0C,KAASY,CAClB,KAAK,KACH,MAAOZ,KAASY,CAClB,KAAK,IACH,MAAcA,GAAPZ,CACT,KAAK,KACH,MAAeY,IAARZ,CACT,KAAK,IACH,MAAOA,GAAOY,CAChB,KAAK,KACH,MAAOZ,IAAQY,CACjB,KAAK,IACH,MAAOZ,GAAOY,CAChB,KAAK,IACH,MAAOZ,GAAOY,CAChB,KAAK,IACH,MAAOZ,GAAOY,CAChB,KAAK,IACH,MAAOZ,GAAOY,CAChB,KAAK,IACH,MAAOZ,GAAOY,CAChB,SACEpI,KAAK+E,WAAW,cAEpB,KACF,KAAK8B,GAAI8B,gBACP,OAAQ2C,EAAIxG,UACV,IAAK,IACH,OAAQqH,EAAEb,EAAIzC,SAChB,KAAK,IACH,OAAQsD,EAAEb,EAAIzC,SAChB,KAAK,IACH,OAAQsD,EAAEb,EAAIzC,SAChB,SACE7I,KAAK+E,WAAW,cAEpB,KACF,KAAK8B,GAAI2C,eACH8B,EAAI7B,OAAOxC,OAASJ,EAAI6C,YAC1B1J,KAAK+E,WAAW,cAEZuG,EAAI7B,OAAOE,OAAQuC,IACvBlM,KAAK+E,WAAU,qBAAsBuG,EAAI7B,OAAOE,KAAI,4BAEtD,IAAIF,GAASyC,EAAQZ,EAAI7B,OAAOE,MAC5BL,EAAOgC,EAAI/J,UAAUV,IAAIsL,EAC7B,OAAO1C,GAAO4C,MAAM,KAAM/C,EAC5B,KAAKzC,GAAIqC,iBACP,MAAIoC,GAAInC,SAASlC,OAASJ,EAAI6C,YAAe4B,EAAIlC,SAG1C+C,EAAEb,EAAItC,QAAQmD,EAAEb,EAAInC,WAFlBgD,EAAEb,EAAItC,QAAQsC,EAAInC,SAASQ,KAGtC,KAAK9C,GAAI6C,WAIP,MAHM4B,GAAI3B,OAAQsC,IAChBjM,KAAK+E,WAAU,qBAAsBuG,EAAI3B,KAAI,+BAExCsC,EAAOX,EAAI3B,KACpB,KAAK9C,GAAIK,QACP,MAAOoE,GAAIjN,KACb,KAAKwI,GAAIiD,gBACP,MAAOwB,GAAI1B,SAAS/I,IAAIsL,EAC1B,KAAKtF,GAAIqD,iBACP,GAAIoC,KAQJ,OAPAhB,GAAIvB,WAAWpI,QAAQ,SAAA4K,GACjBA,EAAKnO,IAAI6I,OAASJ,EAAI6C,WACxB4C,EAAIC,EAAKnO,IAAIuL,MAAQwC,EAAEI,EAAKlO,OAE5BiO,EAAIH,EAAEI,EAAKnO,MAAQ+N,EAAEI,EAAKlO,SAGvBiO,GAEX,MAAOE,GACP,GAAIA,EAAIC,OACN,KAAMD,EAER,IAAIE,GAAQF,EAAIG,SAAW,mBAC3B3M,MAAK+E,WAAU,kCAAoC/E,KAAKM,SAASgL,GAAI,MAAOoB,EAAI,KAAK,OD0DvFtO,IAAK,aACLC,MCvDQ,SAAC8L,GDwDP,GCxDYsC,GAAMlL,UAAAnC,QAAA,GAAAoC,SAAAD,UAAA,IAAG,EAAKA,UAAA,GACxBiL,EAAMhH,MAAK,gBAAiB2E,EAEhC,MADAqC,GAAIC,OAASA,EACPD,KD4DNpO,IAAK,QACLC,MC1DG,SAACoF,GD2DF,GAAImJ,GAAS5M,KC1DXsL,EAAMtL,KAAKiL,WAAWK,IAAI7H,EAC9B,OAAO,YD6DH,GC7DIwI,GAAM1K,UAAAnC,QAAA,GAAAoC,SAAAD,UAAA,MAAKA,UAAA,GAAE2K,EAAO3K,UAAAnC,QAAA,GAAAoC,SAAAD,UAAA,MAAKA,UAAA,ED+D7B,OC/DkCqL,GAAKR,KAAKd,EAAKW,EAAQC,QA/K3DlB,IAmLNrL,GAAQqL,OAASA","file":"expression-parser.min.js","sourcesContent":[null,"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  factory((global.ExpressionParser = {}))\n}(this, function (exports) { 'use strict';\n\n  const OPERATORS = {\n    '+': true,\n    '-': true,\n    '*': true,\n    '/': true,\n    '%': true,\n    '==': true,\n    '!=': true,\n    '<': true,\n    '>': true,\n    '<=': true,\n    '>=': true,\n    '&&': true,\n    '||': true,\n    '!': true,\n    '=': true,\n    '|': true\n  };\n\n  const ESCAPE = {\n    'n': '\\n',\n    'f': '\\f',\n    'r': '\\r',\n    't': '\\t',\n    'v': '\\v',\n    '\\'': '\\'',\n    '\"': '\"'\n  };\n\n  var getPrototypeOf = Object.getPrototypeOf;\n\n  function isUndefined(value) {\n    return typeof value === 'undefined';\n  }\n\n  function isDefined(value) {\n    return typeof value !== 'undefined';\n  }\n\n  function isObject(value) {\n    return value !== null && typeof value === 'object';\n  }\n\n  function isString(value) {\n    return typeof value === 'string';\n  }\n\n  function isBoolean(value) {\n    return typeof value === 'boolean';\n  }\n\n  function helpers__isNumber(value) {\n    return typeof value === 'number';\n  }\n\n  function isDate(value) {\n    return toString.call(value) === '[object Date]';\n  }\n\n  var isArray = Array.isArray;\n\n  function isFunction(value) {\n    return typeof value === 'function';\n  }\n\n  function isRegExp(value) {\n    return toString.call(value) === '[object RegExp]';\n  }\n\n  function copy(source) {\n    if (isArray(source)) {\n      return source.map(copy);\n    } else if (isDate(source)) {\n      return new Date(source.getTime());\n    } else if (isRegExp(source)) {\n      let dest = new RegExp(source.source, source.toString().match(/[^\\/]*$/)[0]);\n      dest.lastIndex = source.lastIndex;\n      return dest;\n    } else if (helpers__isNumber(source) || isString(source) || isBoolean(source) || isFunction(source)) {\n      return source;\n    } else {\n      let dest = {};\n      for (let key in source) {\n        if (source.hasOwnProperty(key)) {\n          dest[key] = copy(source[key]);\n        }\n      }\n      return dest;\n    }\n  }\n\n  function defaults(options = {}, defaults_ = {}) {\n    Object.keys(defaults_).forEach(key => {\n      if (typeof options[key] === 'undefined') {\n        options[key] = copy(defaults_[key]);\n      }\n    });\n    return options;\n  }\n\n  class Lexer {\n\n    constructor(options) {\n      this.options = options;\n    }\n\n    lex(text) {\n      this.text = text;\n      this.index = 0;\n      this.tokens = [];\n\n      while (this.index < this.text.length) {\n        let ch = this.text.charAt(this.index);\n        if (ch === '\"' || ch === '\\'') {\n          this.readString(ch);\n        } else if (this.isNumber(ch) || ch === '.' && this.isNumber(this.peek())) {\n          this.readNumber();\n        } else if (this.isIdent(ch)) {\n          this.readIdent();\n        } else if (this.is(ch, '`')) {\n          this.readBacktickIdent();\n        } else if (this.is(ch, '(){}[].,;:?')) {\n          this.tokens.push({ index: this.index, text: ch });\n          this.index++;\n        } else if (this.isWhitespace(ch)) {\n          this.index++;\n        } else {\n          let ch2 = ch + this.peek();\n          let ch3 = ch2 + this.peek(2);\n          let op1 = OPERATORS[ch];\n          let op2 = OPERATORS[ch2];\n          let op3 = OPERATORS[ch3];\n          if (op1 || op2 || op3) {\n            let token = op3 ? ch3 : (op2 ? ch2 : ch);\n            this.tokens.push({ index: this.index, text: token, operator: true });\n            this.index += token.length;\n          } else {\n            this.throwError('Unexpected next character', this.index, this.index + 1);\n          }\n        }\n      }\n      return this.tokens;\n    }\n\n    is(ch, chars) {\n      return chars.indexOf(ch) !== -1;\n    }\n\n    peek(i) {\n      let num = i || 1;\n      return (this.index + num < this.text.length) ? this.text.charAt(this.index + num) : false;\n    }\n\n    isNumber(ch) {\n      return ('0' <= ch && ch <= '9') && typeof ch === 'string';\n    }\n\n    isWhitespace(ch) {\n      // IE treats non-breaking space as \\u00A0\n      return (ch === ' ' || ch === '\\r' || ch === '\\t' ||\n      ch === '\\n' || ch === '\\v' || ch === '\\u00A0');\n    }\n\n    isIdent(ch) {\n      return ('a' <= ch && ch <= 'z' ||\n      'A' <= ch && ch <= 'Z' ||\n      '_' === ch || ch === '$');\n    }\n\n    isExpOperator(ch) {\n      return (ch === '-' || ch === '+' || this.isNumber(ch));\n    }\n\n    throwError(error, start, end) {\n      end = end || this.index;\n      let colStr = (isDefined(start)\n        ? 's ' + start + '-' + this.index + ' [' + this.text.substring(start, end) + ']'\n        : ' ' + end);\n      throw Error(`Lexer Error: ${error} at column${colStr} in expression [${this.text}].`);\n    }\n\n    readNumber() {\n      let number = '';\n      let start = this.index;\n      while (this.index < this.text.length) {\n        let ch = this.text.charAt(this.index).toLowerCase();\n        if (ch === '.' || this.isNumber(ch)) {\n          number += ch;\n        } else {\n          let peekCh = this.peek();\n          if (ch === 'e' && this.isExpOperator(peekCh)) {\n            number += ch;\n          } else if (this.isExpOperator(ch) &&\n            peekCh && this.isNumber(peekCh) &&\n            number.charAt(number.length - 1) === 'e') {\n            number += ch;\n          } else if (this.isExpOperator(ch) &&\n            (!peekCh || !this.isNumber(peekCh)) &&\n            number.charAt(number.length - 1) === 'e') {\n            this.throwError('Invalid exponent');\n          } else {\n            break;\n          }\n        }\n        this.index++;\n      }\n      this.tokens.push({\n        index: start,\n        text: number,\n        constant: true,\n        value: Number(number)\n      });\n    }\n\n    readBacktickIdent() {\n      let start = this.index;\n      this.index++;\n      let string = '';\n      let rawString = '`';\n      let escape = false;\n      while (this.index < this.text.length) {\n        let ch = this.text.charAt(this.index);\n        rawString += ch;\n        if (escape) {\n          if (ch === 'u') {\n            let hex = this.text.substring(this.index + 1, this.index + 5);\n            if (!hex.match(/[\\da-f]{4}/i)) {\n              this.throwError('Invalid unicode escape [\\\\u' + hex + ']');\n            }\n            this.index += 4;\n            string += String.fromCharCode(parseInt(hex, 16));\n          } else {\n            let rep = ESCAPE[ch];\n            string = string + (rep || ch);\n          }\n          escape = false;\n        } else if (ch === '\\\\') {\n          escape = true;\n        } else if (ch === '`') {\n          this.index++;\n          this.tokens.push({\n            index: start,\n            text: string,\n            rawText: rawString,\n            identifier: true,\n            backtick: true\n          });\n          return;\n        } else {\n          string += ch;\n        }\n        this.index++;\n      }\n      this.throwError('Unterminated backtick identifier', start);\n    }\n\n    readIdent() {\n      let start = this.index;\n      while (this.index < this.text.length) {\n        let ch = this.text.charAt(this.index);\n        if (!(this.isIdent(ch) || this.isNumber(ch))) {\n          break;\n        }\n        this.index++;\n      }\n      this.tokens.push({\n        index: start,\n        text: this.text.slice(start, this.index),\n        identifier: true\n      });\n    }\n\n    readString(quote) {\n      let start = this.index;\n      this.index++;\n      let string = '';\n      let rawString = quote;\n      let escape = false;\n      while (this.index < this.text.length) {\n        let ch = this.text.charAt(this.index);\n        rawString += ch;\n        if (escape) {\n          if (ch === 'u') {\n            let hex = this.text.substring(this.index + 1, this.index + 5);\n            if (!hex.match(/[\\da-f]{4}/i)) {\n              this.throwError('Invalid unicode escape [\\\\u' + hex + ']');\n            }\n            this.index += 4;\n            string += String.fromCharCode(parseInt(hex, 16));\n          } else {\n            let rep = ESCAPE[ch];\n            string = string + (rep || ch);\n          }\n          escape = false;\n        } else if (ch === '\\\\') {\n          escape = true;\n        } else if (ch === quote) {\n          this.index++;\n          this.tokens.push({\n            index: start,\n            text: rawString,\n            constant: true,\n            value: string\n          });\n          return;\n        } else {\n          string += ch;\n        }\n        this.index++;\n      }\n      this.throwError('Unterminated quote', start);\n    }\n  }\n\n  exports.Lexer = Lexer;\n\n  const _ast__DEFAULT_OPTIONS = {};\n\n  class AST {\n\n    constructor(lexer, options) {\n      this.lexer = lexer;\n      this.options = defaults(options, _ast__DEFAULT_OPTIONS);\n      this.constants = {\n        'true': { type: AST.Literal, value: true },\n        'false': { type: AST.Literal, value: false },\n        'null': { type: AST.Literal, value: null },\n        'undefined': { type: AST.Literal, value: undefined }\n      };\n    }\n\n    ast(text) {\n      this.text = text;\n      this.tokens = this.lexer.lex(text);\n\n      let value = this.filterChain();\n      if (this.peek(';')) {\n        // Allow trailing semicolon, not required\n        this.expect(';');\n      }\n      if (this.tokens.length !== 0) {\n        this.throwError('is an unexpected token', this.tokens[0]);\n      }\n      return value;\n    }\n\n    filterChain() {\n      let left = this.expression();\n      let token;\n      while ((token = this.expect('|'))) {\n        left = this.filter(left);\n      }\n      return left;\n    }\n\n    expression() {\n      return this.ternary();\n    }\n\n    ternary() {\n      let test = this.logicalOR();\n      let alternate;\n      let consequent;\n      if (this.expect('?')) {\n        consequent = this.expression();\n        if (this.consume(':')) {\n          alternate = this.expression();\n          return { type: AST.ConditionalExpression, test: test, consequent: consequent, alternate: alternate };\n        }\n      }\n      return test;\n    }\n\n    logicalOR() {\n      let left = this.logicalAND();\n      while (this.expect('||')) {\n        left = { type: AST.LogicalExpression, operator: '||', left: left, right: this.logicalAND() };\n      }\n      return left;\n    }\n\n    logicalAND() {\n      let left = this.equality();\n      while (this.expect('&&')) {\n        left = { type: AST.LogicalExpression, operator: '&&', left: left, right: this.equality() };\n      }\n      return left;\n    }\n\n    equality() {\n      let left = this.relational();\n      let token;\n      while ((token = this.expect('==', '!='))) {\n        left = { type: AST.BinaryExpression, operator: token.text, left: left, right: this.relational() };\n      }\n      return left;\n    }\n\n    relational() {\n      let left = this.additive();\n      let token;\n      while ((token = this.expect('<', '>', '<=', '>='))) {\n        left = { type: AST.BinaryExpression, operator: token.text, left: left, right: this.additive() };\n      }\n      return left;\n    }\n\n    additive() {\n      let left = this.multiplicative();\n      let token;\n      while ((token = this.expect('+', '-'))) {\n        left = { type: AST.BinaryExpression, operator: token.text, left: left, right: this.multiplicative() };\n      }\n      return left;\n    }\n\n    multiplicative() {\n      let left = this.unary();\n      let token;\n      while ((token = this.expect('*', '/', '%'))) {\n        left = { type: AST.BinaryExpression, operator: token.text, left: left, right: this.unary() };\n      }\n      return left;\n    }\n\n    unary() {\n      let token;\n      if ((token = this.expect('+', '-', '!'))) {\n        return { type: AST.UnaryExpression, operator: token.text, prefix: true, argument: this.unary() };\n      } else {\n        return this.primary();\n      }\n    }\n\n    primary() {\n      let primary;\n      if (this.expect('(')) {\n        primary = this.filterChain();\n        this.consume(')');\n      } else if (this.expect('[')) {\n        primary = this.arrayDeclaration();\n      } else if (this.expect('{')) {\n        primary = this.object();\n      } else if (this.constants.hasOwnProperty(this.peek().text)) {\n        primary = copy(this.constants[this.consume().text]);\n      } else if (this.peek().identifier) {\n        primary = this.identifier();\n      } else if (this.peek().constant) {\n        primary = this.constant();\n      } else {\n        this.throwError('not a primary expression', this.peek());\n      }\n\n      let next;\n      while ((next = this.expect('(', '[', '.'))) {\n        if (next.text === '[') {\n          primary = { type: AST.MemberExpression, object: primary, property: this.expression(), computed: true };\n          this.consume(']');\n        } else if (next.text === '.') {\n          primary = { type: AST.MemberExpression, object: primary, property: this.identifier(), computed: false };\n        } else {\n          this.throwError('IMPOSSIBLE');\n        }\n      }\n      return primary;\n    }\n\n    filter(baseExpression) {\n      let args = [baseExpression];\n      let result = { type: AST.CallExpression, callee: this.identifier(), arguments: args, filter: true };\n\n      while (this.expect(':')) {\n        args.push(this.expression());\n      }\n\n      return result;\n    }\n\n    identifier() {\n      let token = this.consume();\n      if (!token.identifier) {\n        this.throwError('is not a valid identifier', token);\n      }\n      return { type: AST.Identifier, name: token.text, backtick: !!token.backtick };\n    }\n\n    constant() {\n      // TODO check that it is a constant\n      return { type: AST.Literal, value: this.consume().value };\n    }\n\n    arrayDeclaration() {\n      let elements = [];\n      if (this.peekToken().text !== ']') {\n        do {\n          if (this.peek(']')) {\n            // Support trailing commas\n            break;\n          }\n          elements.push(this.expression());\n        } while (this.expect(','));\n      }\n      this.consume(']');\n\n      return { type: AST.ArrayExpression, elements: elements };\n    }\n\n    object() {\n      let properties = [], property;\n      if (this.peekToken().text !== '}') {\n        do {\n          if (this.peek('}')) {\n            // Support trailing commas\n            break;\n          }\n          property = { type: AST.Property, kind: 'init' };\n          if (this.peek().constant) {\n            property.key = this.constant();\n          } else if (this.peek().identifier) {\n            property.key = this.identifier();\n          } else {\n            this.throwError('invalid key', this.peek());\n          }\n          this.consume(':');\n          property.value = this.expression();\n          properties.push(property);\n        } while (this.expect(','));\n      }\n      this.consume('}');\n\n      return { type: AST.ObjectExpression, properties: properties };\n    }\n\n    throwError(msg, token) {\n      throw Error(`Syntax Error: Token \\'${token.text}\\' ${msg} at column ${token.index + 1} of the expression [${this.text}] starting at [${this.text.substring(token.index)}].`);\n    }\n\n    consume(e1) {\n      if (this.tokens.length === 0) {\n        throw Error(`Unexpected end of expression: ${this.text}`);\n      }\n\n      let token = this.expect(e1);\n      if (!token) {\n        this.throwError('is unexpected, expecting [' + e1 + ']', this.peek());\n      }\n      return token;\n    }\n\n    peekToken() {\n      if (this.tokens.length === 0) {\n        throw Error(`Unexpected end of expression: ${this.text}`);\n      }\n      return this.tokens[0];\n    }\n\n    peek(e1, e2, e3, e4) {\n      return this.peekAhead(0, e1, e2, e3, e4);\n    }\n\n    peekAhead(i, e1, e2, e3, e4) {\n      if (this.tokens.length > i) {\n        let token = this.tokens[i];\n        let t = token.text;\n        if (t === e1 || t === e2 || t === e3 || t === e4 ||\n          (!e1 && !e2 && !e3 && !e4)) {\n          return token;\n        }\n      }\n      return false;\n    }\n\n    expect(e1, e2, e3, e4) {\n      let token = this.peek(e1, e2, e3, e4);\n      if (token) {\n        this.tokens.shift();\n        return token;\n      }\n      return false;\n    }\n  }\n\n  AST.ConditionalExpression = 'ConditionalExpression';\n  AST.LogicalExpression = 'LogicalExpression';\n  AST.BinaryExpression = 'BinaryExpression';\n  AST.UnaryExpression = 'UnaryExpression';\n  AST.CallExpression = 'CallExpression';\n  AST.MemberExpression = 'MemberExpression';\n  AST.Identifier = 'Identifier';\n  AST.Literal = 'Literal';\n  AST.ArrayExpression = 'ArrayExpression';\n  AST.Property = 'Property';\n  AST.ObjectExpression = 'ObjectExpression';\n\n  AST.PRECEDENCE = {\n    [AST.ConditionalExpression]: 1,\n    [AST.LogicalExpression]: 1,\n    [AST.BinaryExpression]: 2,\n    [AST.UnaryExpression]: 3,\n    [AST.CallExpression]: 4,\n    [AST.MemberExpression]: 5,\n    [AST.Identifier]: 6,\n    [AST.Literal]: 6,\n    [AST.ObjectExpression]: 6,\n    [AST.Property]: 6,\n    [AST.ArrayExpression]: 6,\n  };\n\n  AST.LOGICAL_EXPRESSION_PRECEDENCE = {\n    '||': 1,\n    '&&': 2,\n  };\n\n  AST.BINARY_EXPRESSION_PRECEDENCE = {\n    '==': 1,\n    '!=': 1,\n    '<': 2,\n    '<=': 2,\n    '>': 2,\n    '>=': 2,\n    '+': 3,\n    '-': 3,\n    '*': 4,\n    '/': 4,\n    '%': 4,\n  };\n\n  exports.AST = AST;\n\n  const parser__DEFAULT_OPTIONS = {\n    LexerClass: Lexer,\n    ASTBuilderClass: AST\n  };\n\n  class Parser {\n    constructor(options) {\n      this.options = defaults(options, parser__DEFAULT_OPTIONS);\n      let lexer = new this.options.LexerClass();\n      this.astBuilder = new this.options.ASTBuilderClass(lexer);\n    }\n\n    precedence(expr1, expr2) {\n      var prec = AST.PRECEDENCE;\n      if (prec[expr1.type] < prec[expr2.type]) {\n        return -1;\n      } else if (prec[expr1.type] > prec[expr2.type]) {\n        return +1;\n      } else if (expr1.type === AST.LogicalExpression || expr1.type === AST.BinaryExpression) {\n        let oprec = expr1.type === AST.LogicalExpression ? AST.LOGICAL_EXPRESSION_PRECEDENCE : AST.BINARY_EXPRESSION_PRECEDENCE;\n        if (oprec[expr1.operator] < oprec[expr2.operator]) {\n          return -1;\n        } else if (oprec[expr1.operator] > oprec[expr2.operator]) {\n          return +1;\n        }\n      }\n      return 0;\n    }\n\n    toString(ast, parent) {\n      let str = expr => this.toString(expr, ast);\n      if (parent && this.precedence(ast, parent) < 0) {\n        return `(${this.toString(ast)})`;\n      }\n      switch (ast.type) {\n        case AST.ConditionalExpression:\n          return `${str(ast.test)} ? ${str(ast.consequent)} : ${str(ast.alternate)}`;\n        case AST.LogicalExpression:\n          return `${str(ast.left)} ${ast.operator} ${str(ast.right)}`;\n        case AST.BinaryExpression:\n          return `${str(ast.left)} ${ast.operator} ${str(ast.right)}`;\n        case AST.UnaryExpression:\n          return `${ast.operator}${str(ast.argument)}`;\n        case AST.CallExpression:\n          let args = ast.arguments.slice(1)\n            .map(arg => arg.type === AST.CallExpression ? `:(${str(arg)})` : `:${str(arg)}`).join('');\n          return `${str(ast.arguments[0])}|${ast.callee.name}${args}`;\n        case AST.MemberExpression:\n          if (!ast.computed && ast.property.type === AST.Identifier) {\n            return `${str(ast.object)}.${ast.property.backtick ? '`' + ast.property.name + '`' : ast.property.name }`;\n          }\n          return `${str(ast.object)}[${str(ast.property)}]`;\n        case AST.Identifier:\n          return ast.name;\n        case AST.Literal:\n          return ast.value === undefined ? 'undefined' : JSON.stringify(ast.value);\n        case AST.ArrayExpression:\n          return `[${ast.elements.map(expr => this.toString(expr)).join(', ')}]`;\n        case AST.ObjectExpression:\n          let properties = ast.properties.map(expr => {\n            if (expr.key.type === AST.Identifier || expr.key.type === AST.Literal) {\n              return `${this.toString(expr.key)}: ${this.toString(expr.value)}`;\n            } else {\n              this.throwError('IMPOSSIBLE');\n            }\n          });\n          return `{${properties.join(', ')}}`;\n      }\n    }\n\n    eval(ast, locals = {}, filters = {}) {\n      let e = expr => this.eval(expr, locals, filters);\n      try {\n        switch (ast.type) {\n          case AST.ConditionalExpression:\n            return e(ast.test) ? e(ast.consequent) : e(ast.alternate);\n          case AST.LogicalExpression:\n            switch (ast.operator) {\n              case '&&':\n                return e(ast.left) && e(ast.right);\n              case '||':\n                return e(ast.left) || e(ast.right);\n              default:\n                this.throwError('IMPOSSIBLE');\n            }\n            break;\n          case AST.BinaryExpression:\n            let left = e(ast.left);\n            let right = e(ast.right);\n            switch (ast.operator) {\n              case '==':\n                return left === right;\n              case '!=':\n                return left !== right;\n              case '<':\n                return left < right;\n              case '<=':\n                return left <= right;\n              case '>':\n                return left > right;\n              case '>=':\n                return left >= right;\n              case '+':\n                return left + right;\n              case '-':\n                return left - right;\n              case '*':\n                return left * right;\n              case '/':\n                return left / right;\n              case '%':\n                return left % right;\n              default:\n                this.throwError('IMPOSSIBLE');\n            }\n            break;\n          case AST.UnaryExpression:\n            switch (ast.operator) {\n              case '+':\n                return +e(ast.argument);\n              case '-':\n                return -e(ast.argument);\n              case '!':\n                return !e(ast.argument);\n              default:\n                this.throwError('IMPOSSIBLE');\n            }\n            break;\n          case AST.CallExpression:\n            if (ast.callee.type !== AST.Identifier) {\n              this.throwError('IMPOSSIBLE');\n            }\n            if (!(ast.callee.name in filters)) {\n              this.throwError(`Reference error: [${ast.callee.name}] is not a defined filter`);\n            }\n            let callee = filters[ast.callee.name];\n            let args = ast.arguments.map(e);\n            return callee.apply(null, args);\n          case AST.MemberExpression:\n            if (ast.property.type === AST.Identifier && !ast.computed) {\n              return e(ast.object)[ast.property.name];\n            }\n            return e(ast.object)[e(ast.property)];\n          case AST.Identifier:\n            if (!(ast.name in locals)) {\n              this.throwError(`Reference error: [${ast.name}] is not a defined variable`);\n            }\n            return locals[ast.name];\n          case AST.Literal:\n            return ast.value;\n          case AST.ArrayExpression:\n            return ast.elements.map(e);\n          case AST.ObjectExpression:\n            let res = {};\n            ast.properties.forEach(prop => {\n              if (prop.key.type === AST.Identifier) {\n                res[prop.key.name] = e(prop.value);\n              } else {\n                res[e(prop.key)] = e(prop.value);\n              }\n            });\n            return res;\n        }\n      } catch (err) {\n        if (err.bubble) {\n          throw err;\n        }\n        let info = (err.message || 'No info available');\n        this.throwError(`There was an error evaluating \\`${this.toString(ast)}\\` (${info})`, true);\n      }\n    }\n\n    throwError(msg, bubble = false) {\n      let err = Error(`Parse Error: ${msg}`);\n      err.bubble = bubble;\n      throw err;\n    }\n\n    parse(text) {\n      let ast = this.astBuilder.ast(text);\n      return (locals = {}, filters = {}) => this.eval(ast, locals, filters);\n    }\n  }\n\n  exports.Parser = Parser;\n\n  'use strict';\n\n}));\n"],"sourceRoot":"/source/"}