{"version":3,"sources":["expression-parser.min.js","/source/expression-parser.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","global","factory","exports","module","require","define","amd","MyLibrary","defaults","this","isDefined","value","isDate","toString","call","isRegExp","copy","source","isArray","map","Date","getTime","dest","RegExp","match","lastIndex","hasOwnProperty","isAssignable","_x","_again","ast","type","AST","Identifier","MemberExpression","object","OPERATORS","+","-","*","/","%","===","!==","==","!=","<",">","<=",">=","&&","||","!","=","|","ESCAPE","n","f","r","t","v","'","\"","getPrototypeOf","Array","Lexer","options","text","index","tokens","ch","charAt","readString","isNumber","peek","readNumber","isIdent","readIdent","is","push","isWhitespace","ch2","ch3","op1","op2","op3","token","operator","throwError","chars","indexOf","num","error","start","end","colStr","substring","Error","number","toLowerCase","peekCh","isExpOperator","constant","Number","slice","identifier","quote","string","rawString","escape","hex","String","fromCharCode","parseInt","rep","DEFAULT_OPTIONS","allowAssignments","multipleExpressions","lexer","constants","true","Literal","false","null","undefined","lex","program","expressionStatement","body","expect","Program","ExpressionStatement","expression","filterChain","left","filter","assignment","result","ternary","AssignmentExpression","right","test","logicalOR","alternate","consequent","consume","ConditionalExpression","logicalAND","LogicalExpression","equality","relational","BinaryExpression","additive","multiplicative","unary","UnaryExpression","prefix","argument","primary","arrayDeclaration","next","CallExpression","callee","arguments","parseArguments","property","computed","baseExpression","args","peekToken","name","elements","ArrayExpression","properties","Property","kind","ObjectExpression","msg","e1","e2","e3","e4","peekAhead","shift","Parser","astBuilder","locals","_this","e","expr","eval","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","Symbol","iterator","done","err","apply","res","forEach","prop","_this2"],"mappings":"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","file":"expression-parser.min.js","sourcesContent":[null,"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('defaults')) :\n  typeof define === 'function' && define.amd ? define(['exports', 'defaults'], factory) :\n  factory((global.MyLibrary = {}), global.defaults)\n}(this, function (exports, defaults) { 'use strict';\n\n  defaults = ('default' in defaults ? defaults['default'] : defaults);\n\n  const OPERATORS = {\n    '+': true,\n    '-': true,\n    '*': true,\n    '/': true,\n    '%': true,\n    '===': true,\n    '!==': true,\n    '==': true,\n    '!=': true,\n    '<': true,\n    '>': true,\n    '<=': true,\n    '>=': true,\n    '&&': true,\n    '||': true,\n    '!': true,\n    '=': true,\n    '|': true\n  };\n\n  const ESCAPE = {\n    'n': '\\n',\n    'f': '\\f',\n    'r': '\\r',\n    't': '\\t',\n    'v': '\\v',\n    '\\'': '\\'',\n    '\"': '\"'\n  };\n\n  var getPrototypeOf = Object.getPrototypeOf;\n\n  function isUndefined(value) {\n    return typeof value === 'undefined';\n  }\n\n  function isDefined(value) {\n    return typeof value !== 'undefined';\n  }\n\n  function isObject(value) {\n    return value !== null && typeof value === 'object';\n  }\n\n  function isString(value) {\n    return typeof value === 'string';\n  }\n\n  function helpers__isNumber(value) {\n    return typeof value === 'number';\n  }\n\n  function isDate(value) {\n    return toString.call(value) === '[object Date]';\n  }\n\n  var isArray = Array.isArray;\n\n  function isFunction(value) {\n    return typeof value === 'function';\n  }\n\n  function isRegExp(value) {\n    return toString.call(value) === '[object RegExp]';\n  }\n\n  function copy(source) {\n    if (isArray(source)) {\n      return source.map(copy);\n    } else if (isDate(source)) {\n      return new Date(source.getTime());\n    } else if (isRegExp(source)) {\n      let dest = new RegExp(source.source, source.toString().match(/[^\\/]*$/)[0]);\n      dest.lastIndex = source.lastIndex;\n      return dest;\n    } else {\n      let dest = {};\n      for (let key in source) {\n        if (source.hasOwnProperty(key)) {\n          dest[key] = copy(source[key]);\n        }\n      }\n      return dest;\n    }\n  }\n\n  class Lexer {\n\n    constructor(options) {\n      this.options = options;\n    }\n\n    lex(text) {\n      this.text = text;\n      this.index = 0;\n      this.tokens = [];\n\n      while (this.index < this.text.length) {\n        let ch = this.text.charAt(this.index);\n        if (ch === '\"' || ch === '\\'') {\n          this.readString(ch);\n        } else if (this.isNumber(ch) || ch === '.' && this.isNumber(this.peek())) {\n          this.readNumber();\n        } else if (this.isIdent(ch)) {\n          this.readIdent();\n        } else if (this.is(ch, '(){}[].,;:?')) {\n          this.tokens.push({ index: this.index, text: ch });\n          this.index++;\n        } else if (this.isWhitespace(ch)) {\n          this.index++;\n        } else {\n          let ch2 = ch + this.peek();\n          let ch3 = ch2 + this.peek(2);\n          let op1 = OPERATORS[ch];\n          let op2 = OPERATORS[ch2];\n          let op3 = OPERATORS[ch3];\n          if (op1 || op2 || op3) {\n            let token = op3 ? ch3 : (op2 ? ch2 : ch);\n            this.tokens.push({ index: this.index, text: token, operator: true });\n            this.index += token.length;\n          } else {\n            this.throwError('Unexpected next character', this.index, this.index + 1);\n          }\n        }\n      }\n      return this.tokens;\n    }\n\n    is(ch, chars) {\n      return chars.indexOf(ch) !== -1;\n    }\n\n    peek(i) {\n      let num = i || 1;\n      return (this.index + num < this.text.length) ? this.text.charAt(this.index + num) : false;\n    }\n\n    isNumber(ch) {\n      return ('0' <= ch && ch <= '9') && typeof ch === 'string';\n    }\n\n    isWhitespace(ch) {\n      // IE treats non-breaking space as \\u00A0\n      return (ch === ' ' || ch === '\\r' || ch === '\\t' ||\n      ch === '\\n' || ch === '\\v' || ch === '\\u00A0');\n    }\n\n    isIdent(ch) {\n      return ('a' <= ch && ch <= 'z' ||\n      'A' <= ch && ch <= 'Z' ||\n      '_' === ch || ch === '$');\n    }\n\n    isExpOperator(ch) {\n      return (ch === '-' || ch === '+' || this.isNumber(ch));\n    }\n\n    throwError(error, start, end) {\n      end = end || this.index;\n      let colStr = (isDefined(start)\n        ? 's ' + start + '-' + this.index + ' [' + this.text.substring(start, end) + ']'\n        : ' ' + end);\n      throw Error(`Lexer Error: ${error} at column${colStr} in expression [${this.text}].`);\n    }\n\n    readNumber() {\n      let number = '';\n      let start = this.index;\n      while (this.index < this.text.length) {\n        let ch = this.text.charAt(this.index).toLowerCase();\n        if (ch === '.' || this.isNumber(ch)) {\n          number += ch;\n        } else {\n          let peekCh = this.peek();\n          if (ch === 'e' && this.isExpOperator(peekCh)) {\n            number += ch;\n          } else if (this.isExpOperator(ch) &&\n            peekCh && this.isNumber(peekCh) &&\n            number.charAt(number.length - 1) === 'e') {\n            number += ch;\n          } else if (this.isExpOperator(ch) &&\n            (!peekCh || !this.isNumber(peekCh)) &&\n            number.charAt(number.length - 1) === 'e') {\n            this.throwError('Invalid exponent');\n          } else {\n            break;\n          }\n        }\n        this.index++;\n      }\n      this.tokens.push({\n        index: start,\n        text: number,\n        constant: true,\n        value: Number(number)\n      });\n    }\n\n    readIdent() {\n      let start = this.index;\n      while (this.index < this.text.length) {\n        let ch = this.text.charAt(this.index);\n        if (!(this.isIdent(ch) || this.isNumber(ch))) {\n          break;\n        }\n        this.index++;\n      }\n      this.tokens.push({\n        index: start,\n        text: this.text.slice(start, this.index),\n        identifier: true\n      });\n    }\n\n    readString(quote) {\n      let start = this.index;\n      this.index++;\n      let string = '';\n      let rawString = quote;\n      let escape = false;\n      while (this.index < this.text.length) {\n        let ch = this.text.charAt(this.index);\n        rawString += ch;\n        if (escape) {\n          if (ch === 'u') {\n            let hex = this.text.substring(this.index + 1, this.index + 5);\n            if (!hex.match(/[\\da-f]{4}/i)) {\n              this.throwError('Invalid unicode escape [\\\\u' + hex + ']');\n            }\n            this.index += 4;\n            string += String.fromCharCode(parseInt(hex, 16));\n          } else {\n            let rep = ESCAPE[ch];\n            string = string + (rep || ch);\n          }\n          escape = false;\n        } else if (ch === '\\\\') {\n          escape = true;\n        } else if (ch === quote) {\n          this.index++;\n          this.tokens.push({\n            index: start,\n            text: rawString,\n            constant: true,\n            value: string\n          });\n          return;\n        } else {\n          string += ch;\n        }\n        this.index++;\n      }\n      this.throwError('Unterminated quote', start);\n    }\n  }\n\n  exports.Lexer = Lexer;\n\n  const DEFAULT_OPTIONS = {\n    allowAssignments: true,\n    multipleExpressions: true\n  };\n\n  class AST {\n\n    constructor(lexer, options) {\n      this.lexer = lexer;\n      this.options = defaults(options, DEFAULT_OPTIONS);\n      this.constants = {\n        'true': { type: AST.Literal, value: true },\n        'false': { type: AST.Literal, value: false },\n        'null': { type: AST.Literal, value: null },\n        'undefined': { type: AST.Literal, value: undefined }\n      };\n    }\n\n    ast(text) {\n      this.text = text;\n      this.tokens = this.lexer.lex(text);\n\n      let value = this.options.multipleExpressions ? this.program() : this.expressionStatement();\n\n      if (this.tokens.length !== 0) {\n        this.throwError('is an unexpected token', this.tokens[0]);\n      }\n\n      return value;\n    }\n\n    program() {\n      let body = [];\n      while (true) {\n        if (this.tokens.length > 0 && !this.peek('}', ')', ';', ']')) {\n          body.push(this.expressionStatement());\n        }\n        if (!this.expect(';')) {\n          return { type: AST.Program, body: body };\n        }\n      }\n    }\n\n    expressionStatement() {\n      return { type: AST.ExpressionStatement, expression: this.filterChain() };\n    }\n\n    filterChain() {\n      let left = this.expression();\n      let token;\n      while ((token = this.expect('|'))) {\n        left = this.filter(left);\n      }\n      return left;\n    }\n\n    expression() {\n      return this.assignment();\n    }\n\n    assignment() {\n      let result = this.ternary();\n      if (this.options.allowAssignments && this.expect('=')) {\n        result = { type: AST.AssignmentExpression, left: result, right: this.assignment(), operator: '=' };\n      }\n      return result;\n    }\n\n    ternary() {\n      let test = this.logicalOR();\n      let alternate;\n      let consequent;\n      if (this.expect('?')) {\n        consequent = this.expression();\n        if (this.consume(':')) {\n          alternate = this.expression();\n          return { type: AST.ConditionalExpression, test: test, consequent: consequent, alternate: alternate };\n        }\n      }\n      return test;\n    }\n\n    logicalOR() {\n      let left = this.logicalAND();\n      while (this.expect('||')) {\n        left = { type: AST.LogicalExpression, operator: '||', left: left, right: this.logicalAND() };\n      }\n      return left;\n    }\n\n    logicalAND() {\n      let left = this.equality();\n      while (this.expect('&&')) {\n        left = { type: AST.LogicalExpression, operator: '&&', left: left, right: this.equality() };\n      }\n      return left;\n    }\n\n    equality() {\n      let left = this.relational();\n      let token;\n      while ((token = this.expect('==', '!=', '===', '!=='))) {\n        left = { type: AST.BinaryExpression, operator: token.text, left: left, right: this.relational() };\n      }\n      return left;\n    }\n\n    relational() {\n      let left = this.additive();\n      let token;\n      while ((token = this.expect('<', '>', '<=', '>='))) {\n        left = { type: AST.BinaryExpression, operator: token.text, left: left, right: this.additive() };\n      }\n      return left;\n    }\n\n    additive() {\n      let left = this.multiplicative();\n      let token;\n      while ((token = this.expect('+', '-'))) {\n        left = { type: AST.BinaryExpression, operator: token.text, left: left, right: this.multiplicative() };\n      }\n      return left;\n    }\n\n    multiplicative() {\n      let left = this.unary();\n      let token;\n      while ((token = this.expect('*', '/', '%'))) {\n        left = { type: AST.BinaryExpression, operator: token.text, left: left, right: this.unary() };\n      }\n      return left;\n    }\n\n    unary() {\n      let token;\n      if ((token = this.expect('+', '-', '!'))) {\n        return { type: AST.UnaryExpression, operator: token.text, prefix: true, argument: this.unary() };\n      } else {\n        return this.primary();\n      }\n    }\n\n    primary() {\n      let primary;\n      if (this.expect('(')) {\n        primary = this.filterChain();\n        this.consume(')');\n      } else if (this.expect('[')) {\n        primary = this.arrayDeclaration();\n      } else if (this.expect('{')) {\n        primary = this.object();\n      } else if (this.constants.hasOwnProperty(this.peek().text)) {\n        primary = copy(this.constants[this.consume().text]);\n      } else if (this.peek().identifier) {\n        primary = this.identifier();\n      } else if (this.peek().constant) {\n        primary = this.constant();\n      } else {\n        this.throwError('not a primary expression', this.peek());\n      }\n\n      let next;\n      while ((next = this.expect('(', '[', '.'))) {\n        if (next.text === '(') {\n          primary = { type: AST.CallExpression, callee: primary, arguments: this.parseArguments() };\n          this.consume(')');\n        } else if (next.text === '[') {\n          primary = { type: AST.MemberExpression, object: primary, property: this.expression(), computed: true };\n          this.consume(']');\n        } else if (next.text === '.') {\n          primary = { type: AST.MemberExpression, object: primary, property: this.identifier(), computed: false };\n        } else {\n          this.throwError('IMPOSSIBLE');\n        }\n      }\n      return primary;\n    }\n\n    filter(baseExpression) {\n      let args = [baseExpression];\n      let result = { type: AST.CallExpression, callee: this.identifier(), arguments: args, filter: true };\n\n      while (this.expect(':')) {\n        args.push(this.expression());\n      }\n\n      return result;\n    }\n\n    parseArguments() {\n      let args = [];\n      if (this.peekToken().text !== ')') {\n        do {\n          args.push(this.expression());\n        } while (this.expect(','));\n      }\n      return args;\n    }\n\n    identifier() {\n      let token = this.consume();\n      if (!token.identifier) {\n        this.throwError('is not a valid identifier', token);\n      }\n      return { type: AST.Identifier, name: token.text };\n    }\n\n    constant() {\n      // TODO check that it is a constant\n      return { type: AST.Literal, value: this.consume().value };\n    }\n\n    arrayDeclaration() {\n      let elements = [];\n      if (this.peekToken().text !== ']') {\n        do {\n          if (this.peek(']')) {\n            // Support trailing commas per ES5.1.\n            break;\n          }\n          elements.push(this.expression());\n        } while (this.expect(','));\n      }\n      this.consume(']');\n\n      return { type: AST.ArrayExpression, elements: elements };\n    }\n\n    object() {\n      let properties = [], property;\n      if (this.peekToken().text !== '}') {\n        do {\n          if (this.peek('}')) {\n            // Support trailing commas per ES5.1.\n            break;\n          }\n          property = { type: AST.Property, kind: 'init' };\n          if (this.peek().constant) {\n            property.key = this.constant();\n          } else if (this.peek().identifier) {\n            property.key = this.identifier();\n          } else {\n            this.throwError('invalid key', this.peek());\n          }\n          this.consume(':');\n          property.value = this.expression();\n          properties.push(property);\n        } while (this.expect(','));\n      }\n      this.consume('}');\n\n      return { type: AST.ObjectExpression, properties: properties };\n    }\n\n    throwError(msg, token) {\n      throw Error(`Syntax Error: Token \\'${token.text}\\' ${msg} at column ${token.index + 1} of the expression [${this.text}] starting at [${this.text.substring(token.index)}].`);\n    }\n\n    consume(e1) {\n      if (this.tokens.length === 0) {\n        throw Error(`Unexpected end of expression: ${this.text}`);\n      }\n\n      let token = this.expect(e1);\n      if (!token) {\n        this.throwError('is unexpected, expecting [' + e1 + ']', this.peek());\n      }\n      return token;\n    }\n\n    peekToken() {\n      if (this.tokens.length === 0) {\n        throw Error(`Unexpected end of expression: ${this.text}`);\n      }\n      return this.tokens[0];\n    }\n\n    peek(e1, e2, e3, e4) {\n      return this.peekAhead(0, e1, e2, e3, e4);\n    }\n\n    peekAhead(i, e1, e2, e3, e4) {\n      if (this.tokens.length > i) {\n        let token = this.tokens[i];\n        let t = token.text;\n        if (t === e1 || t === e2 || t === e3 || t === e4 ||\n          (!e1 && !e2 && !e3 && !e4)) {\n          return token;\n        }\n      }\n      return false;\n    }\n\n    expect(e1, e2, e3, e4) {\n      let token = this.peek(e1, e2, e3, e4);\n      if (token) {\n        this.tokens.shift();\n        return token;\n      }\n      return false;\n    }\n  }\n\n  AST.Program = 'Program';\n  AST.ExpressionStatement = 'ExpressionStatement';\n  AST.AssignmentExpression = 'AssignmentExpression';\n  AST.ConditionalExpression = 'ConditionalExpression';\n  AST.LogicalExpression = 'LogicalExpression';\n  AST.BinaryExpression = 'BinaryExpression';\n  AST.UnaryExpression = 'UnaryExpression';\n  AST.CallExpression = 'CallExpression';\n  AST.MemberExpression = 'MemberExpression';\n  AST.Identifier = 'Identifier';\n  AST.Literal = 'Literal';\n  AST.ArrayExpression = 'ArrayExpression';\n  AST.Property = 'Property';\n  AST.ObjectExpression = 'ObjectExpression';\n\n  exports.AST = AST;\n\n  function isAssignable(ast) {\n    if (ast.type === AST.Identifier) {\n      return true;\n    } else if (ast.type === AST.MemberExpression) {\n      return isAssignable(ast.object);\n    } else {\n      return false;\n    }\n  }\n\n  class Parser {\n    constructor(astBuilder, options) {\n      this.astBuilder = astBuilder;\n    }\n\n    eval(ast, locals) {\n      let e = expr => this.eval(expr, locals);\n      switch (ast.type) {\n        case AST.Program:\n          let result;\n          for (let expr of ast.body) {\n            result = e(expr);\n          }\n          return result;\n        case AST.ExpressionStatement:\n          return e(ast.expression);\n        case AST.ConditionalExpression:\n          return e(ast.test) ? e(ast.consequent) : e(ast.alternate);\n        case AST.LogicalExpression:\n          switch (ast.operator) {\n            case '&&':\n              return e(ast.left) && e(ast.right);\n            case '||':\n              return e(ast.left) || e(ast.right);\n            default:\n              throw Error();\n          }\n          break;\n        case AST.BinaryExpression:\n          let left = e(ast.left);\n          let right = e(ast.right);\n          switch (ast.operator) {\n            case '==':\n            case '===':\n              return left === right;\n            case '!=':\n            case '!==':\n              return left !== right;\n            case '<':\n              return left < right;\n            case '<=':\n              return left <= right;\n            case '>':\n              return left > right;\n            case '>=':\n              return left >= right;\n            case '+':\n              return left + right;\n            case '-':\n              return left - right;\n            case '*':\n              return left * right;\n            case '/':\n              return left / right;\n            case '%':\n              return left % right;\n            default:\n              throw Error();\n          }\n          break;\n        case AST.UnaryExpression:\n          switch (ast.operator) {\n            case '+':\n              return +e(ast.argument);\n            case '-':\n              return -e(ast.argument);\n            case '!':\n              return !e(ast.argument);\n            default:\n              throw Error();\n          }\n          break;\n        case AST.CallExpression:\n          let callee = e(ast.callee);\n          let args = ast.arguments.map(e);\n          return callee.apply(null, args);\n        case AST.MemberExpression:\n          if (ast.property.type === AST.Identifier && !ast.computed) {\n            return e(ast.object)[ast.property.name];\n          }\n          return e(ast.object)[e(ast.property)];\n        case AST.Identifier:\n          if (!(ast.name in locals)) {\n            throw Error(`Reference error: ${ast.name} is not defined`);\n          }\n          return locals[ast.name];\n        case AST.Literal:\n          return ast.value;\n        case AST.ArrayExpression:\n          return ast.elements.map(e);\n        case AST.ObjectExpression:\n          let res = {};\n          ast.properties.forEach(prop => {\n            res[e(prop.key)] = e(prop.value);\n          });\n          return res;\n        case AST.AssignmentExpression:\n          if (!isAssignable(ast.left)) {\n            throw Error('Trying to assign a value to a non l-value');\n          }\n          locals[e(ast.left)] = e(ast.right);\n          return undefined;\n      }\n    }\n\n    parse(text) {\n      let ast = this.astBuilder.ast(text);\n      return locals => this.eval(ast, locals);\n    }\n  }\n\n  exports.Parser = Parser;\n\n  'use strict';\n\n}));\n"],"sourceRoot":"/source/"}