{"version":3,"sources":["expression-parser.min.js","/source/expression-parser.js"],"names":["_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","i","length","descriptor","protoProps","staticProps","prototype","global","factory","exports","module","define","amd","ExpressionParser","this","isDefined","isString","isBoolean","helpers__isNumber","isDate","toString","call","isFunction","isRegExp","copy","source","isArray","map","Date","getTime","dest","RegExp","match","lastIndex","hasOwnProperty","defaults","options","arguments","undefined","defaults_","keys","forEach","_AST$PRECEDENCE","OPERATORS","+","-","*","/","%","==","!=","<",">","<=",">=","&&","||","!","=","|","ESCAPE","n","f","r","t","v","'","\"","getPrototypeOf","Array","Lexer","text","index","tokens","ch","charAt","readString","isNumber","peek","readNumber","isIdent","readIdent","is","push","isWhitespace","ch2","ch3","op1","op2","op3","token","operator","throwError","chars","indexOf","num","error","start","end","colStr","substring","Error","number","toLowerCase","peekCh","isExpOperator","constant","Number","slice","identifier","quote","string","rawString","escape","hex","String","fromCharCode","parseInt","rep","_ast__DEFAULT_OPTIONS","AST","lexer","constants","true","type","Literal","false","null","lex","filterChain","expect","left","expression","filter","ternary","test","logicalOR","alternate","consequent","consume","ConditionalExpression","logicalAND","LogicalExpression","right","equality","relational","BinaryExpression","additive","multiplicative","unary","UnaryExpression","prefix","argument","primary","arrayDeclaration","object","next","MemberExpression","property","computed","baseExpression","args","result","CallExpression","callee","Identifier","name","elements","peekToken","ArrayExpression","properties","Property","kind","ObjectExpression","msg","e1","e2","e3","e4","peekAhead","shift","PRECEDENCE","LOGICAL_EXPRESSION_PRECEDENCE","BINARY_EXPRESSION_PRECEDENCE","parser__DEFAULT_OPTIONS","LexerClass","ASTBuilderClass","Parser","astBuilder","expr1","expr2","prec","oprec","ast","parent","_this","str","expr","precedence","arg","join","JSON","stringify","_this2","locals","filters","e","eval","apply","res","prop","err","bubble","info","message","_this3"],"mappings":"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","file":"expression-parser.min.js","sourcesContent":[null,"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  factory((global.ExpressionParser = {}))\n}(this, function (exports) { 'use strict';\n\n  const OPERATORS = {\n    '+': true,\n    '-': true,\n    '*': true,\n    '/': true,\n    '%': true,\n    '==': true,\n    '!=': true,\n    '<': true,\n    '>': true,\n    '<=': true,\n    '>=': true,\n    '&&': true,\n    '||': true,\n    '!': true,\n    '=': true,\n    '|': true\n  };\n\n  const ESCAPE = {\n    'n': '\\n',\n    'f': '\\f',\n    'r': '\\r',\n    't': '\\t',\n    'v': '\\v',\n    '\\'': '\\'',\n    '\"': '\"'\n  };\n\n  var getPrototypeOf = Object.getPrototypeOf;\n\n  function isUndefined(value) {\n    return typeof value === 'undefined';\n  }\n\n  function isDefined(value) {\n    return typeof value !== 'undefined';\n  }\n\n  function isObject(value) {\n    return value !== null && typeof value === 'object';\n  }\n\n  function isString(value) {\n    return typeof value === 'string';\n  }\n\n  function isBoolean(value) {\n    return typeof value === 'boolean';\n  }\n\n  function helpers__isNumber(value) {\n    return typeof value === 'number';\n  }\n\n  function isDate(value) {\n    return toString.call(value) === '[object Date]';\n  }\n\n  var isArray = Array.isArray;\n\n  function isFunction(value) {\n    return typeof value === 'function';\n  }\n\n  function isRegExp(value) {\n    return toString.call(value) === '[object RegExp]';\n  }\n\n  function copy(source) {\n    if (isArray(source)) {\n      return source.map(copy);\n    } else if (isDate(source)) {\n      return new Date(source.getTime());\n    } else if (isRegExp(source)) {\n      let dest = new RegExp(source.source, source.toString().match(/[^\\/]*$/)[0]);\n      dest.lastIndex = source.lastIndex;\n      return dest;\n    } else if (helpers__isNumber(source) || isString(source) || isBoolean(source) || isFunction(source)) {\n      return source;\n    } else {\n      let dest = {};\n      for (let key in source) {\n        if (source.hasOwnProperty(key)) {\n          dest[key] = copy(source[key]);\n        }\n      }\n      return dest;\n    }\n  }\n\n  function defaults(options = {}, defaults_ = {}) {\n    Object.keys(defaults_).forEach(key => {\n      if (typeof options[key] === 'undefined') {\n        options[key] = copy(defaults_[key]);\n      }\n    });\n    return options;\n  }\n\n  class Lexer {\n\n    constructor(options) {\n      this.options = options;\n    }\n\n    lex(text) {\n      this.text = text;\n      this.index = 0;\n      this.tokens = [];\n\n      while (this.index < this.text.length) {\n        let ch = this.text.charAt(this.index);\n        if (ch === '\"' || ch === '\\'') {\n          this.readString(ch);\n        } else if (this.isNumber(ch) || ch === '.' && this.isNumber(this.peek())) {\n          this.readNumber();\n        } else if (this.isIdent(ch)) {\n          this.readIdent();\n        } else if (this.is(ch, '(){}[].,;:?')) {\n          this.tokens.push({ index: this.index, text: ch });\n          this.index++;\n        } else if (this.isWhitespace(ch)) {\n          this.index++;\n        } else {\n          let ch2 = ch + this.peek();\n          let ch3 = ch2 + this.peek(2);\n          let op1 = OPERATORS[ch];\n          let op2 = OPERATORS[ch2];\n          let op3 = OPERATORS[ch3];\n          if (op1 || op2 || op3) {\n            let token = op3 ? ch3 : (op2 ? ch2 : ch);\n            this.tokens.push({ index: this.index, text: token, operator: true });\n            this.index += token.length;\n          } else {\n            this.throwError('Unexpected next character', this.index, this.index + 1);\n          }\n        }\n      }\n      return this.tokens;\n    }\n\n    is(ch, chars) {\n      return chars.indexOf(ch) !== -1;\n    }\n\n    peek(i) {\n      let num = i || 1;\n      return (this.index + num < this.text.length) ? this.text.charAt(this.index + num) : false;\n    }\n\n    isNumber(ch) {\n      return ('0' <= ch && ch <= '9') && typeof ch === 'string';\n    }\n\n    isWhitespace(ch) {\n      // IE treats non-breaking space as \\u00A0\n      return (ch === ' ' || ch === '\\r' || ch === '\\t' ||\n      ch === '\\n' || ch === '\\v' || ch === '\\u00A0');\n    }\n\n    isIdent(ch) {\n      return ('a' <= ch && ch <= 'z' ||\n      'A' <= ch && ch <= 'Z' ||\n      '_' === ch || ch === '$');\n    }\n\n    isExpOperator(ch) {\n      return (ch === '-' || ch === '+' || this.isNumber(ch));\n    }\n\n    throwError(error, start, end) {\n      end = end || this.index;\n      let colStr = (isDefined(start)\n        ? 's ' + start + '-' + this.index + ' [' + this.text.substring(start, end) + ']'\n        : ' ' + end);\n      throw Error(`Lexer Error: ${error} at column${colStr} in expression [${this.text}].`);\n    }\n\n    readNumber() {\n      let number = '';\n      let start = this.index;\n      while (this.index < this.text.length) {\n        let ch = this.text.charAt(this.index).toLowerCase();\n        if (ch === '.' || this.isNumber(ch)) {\n          number += ch;\n        } else {\n          let peekCh = this.peek();\n          if (ch === 'e' && this.isExpOperator(peekCh)) {\n            number += ch;\n          } else if (this.isExpOperator(ch) &&\n            peekCh && this.isNumber(peekCh) &&\n            number.charAt(number.length - 1) === 'e') {\n            number += ch;\n          } else if (this.isExpOperator(ch) &&\n            (!peekCh || !this.isNumber(peekCh)) &&\n            number.charAt(number.length - 1) === 'e') {\n            this.throwError('Invalid exponent');\n          } else {\n            break;\n          }\n        }\n        this.index++;\n      }\n      this.tokens.push({\n        index: start,\n        text: number,\n        constant: true,\n        value: Number(number)\n      });\n    }\n\n    readIdent() {\n      let start = this.index;\n      while (this.index < this.text.length) {\n        let ch = this.text.charAt(this.index);\n        if (!(this.isIdent(ch) || this.isNumber(ch))) {\n          break;\n        }\n        this.index++;\n      }\n      this.tokens.push({\n        index: start,\n        text: this.text.slice(start, this.index),\n        identifier: true\n      });\n    }\n\n    readString(quote) {\n      let start = this.index;\n      this.index++;\n      let string = '';\n      let rawString = quote;\n      let escape = false;\n      while (this.index < this.text.length) {\n        let ch = this.text.charAt(this.index);\n        rawString += ch;\n        if (escape) {\n          if (ch === 'u') {\n            let hex = this.text.substring(this.index + 1, this.index + 5);\n            if (!hex.match(/[\\da-f]{4}/i)) {\n              this.throwError('Invalid unicode escape [\\\\u' + hex + ']');\n            }\n            this.index += 4;\n            string += String.fromCharCode(parseInt(hex, 16));\n          } else {\n            let rep = ESCAPE[ch];\n            string = string + (rep || ch);\n          }\n          escape = false;\n        } else if (ch === '\\\\') {\n          escape = true;\n        } else if (ch === quote) {\n          this.index++;\n          this.tokens.push({\n            index: start,\n            text: rawString,\n            constant: true,\n            value: string\n          });\n          return;\n        } else {\n          string += ch;\n        }\n        this.index++;\n      }\n      this.throwError('Unterminated quote', start);\n    }\n  }\n\n  exports.Lexer = Lexer;\n\n  const _ast__DEFAULT_OPTIONS = {};\n\n  class AST {\n\n    constructor(lexer, options) {\n      this.lexer = lexer;\n      this.options = defaults(options, _ast__DEFAULT_OPTIONS);\n      this.constants = {\n        'true': { type: AST.Literal, value: true },\n        'false': { type: AST.Literal, value: false },\n        'null': { type: AST.Literal, value: null },\n        'undefined': { type: AST.Literal, value: undefined }\n      };\n    }\n\n    ast(text) {\n      this.text = text;\n      this.tokens = this.lexer.lex(text);\n\n      let value = this.filterChain();\n      if (this.peek(';')) {\n        // Allow trailing semicolon, not required\n        this.expect(';');\n      }\n      if (this.tokens.length !== 0) {\n        this.throwError('is an unexpected token', this.tokens[0]);\n      }\n      return value;\n    }\n\n    filterChain() {\n      let left = this.expression();\n      let token;\n      while ((token = this.expect('|'))) {\n        left = this.filter(left);\n      }\n      return left;\n    }\n\n    expression() {\n      return this.ternary();\n    }\n\n    ternary() {\n      let test = this.logicalOR();\n      let alternate;\n      let consequent;\n      if (this.expect('?')) {\n        consequent = this.expression();\n        if (this.consume(':')) {\n          alternate = this.expression();\n          return { type: AST.ConditionalExpression, test: test, consequent: consequent, alternate: alternate };\n        }\n      }\n      return test;\n    }\n\n    logicalOR() {\n      let left = this.logicalAND();\n      while (this.expect('||')) {\n        left = { type: AST.LogicalExpression, operator: '||', left: left, right: this.logicalAND() };\n      }\n      return left;\n    }\n\n    logicalAND() {\n      let left = this.equality();\n      while (this.expect('&&')) {\n        left = { type: AST.LogicalExpression, operator: '&&', left: left, right: this.equality() };\n      }\n      return left;\n    }\n\n    equality() {\n      let left = this.relational();\n      let token;\n      while ((token = this.expect('==', '!='))) {\n        left = { type: AST.BinaryExpression, operator: token.text, left: left, right: this.relational() };\n      }\n      return left;\n    }\n\n    relational() {\n      let left = this.additive();\n      let token;\n      while ((token = this.expect('<', '>', '<=', '>='))) {\n        left = { type: AST.BinaryExpression, operator: token.text, left: left, right: this.additive() };\n      }\n      return left;\n    }\n\n    additive() {\n      let left = this.multiplicative();\n      let token;\n      while ((token = this.expect('+', '-'))) {\n        left = { type: AST.BinaryExpression, operator: token.text, left: left, right: this.multiplicative() };\n      }\n      return left;\n    }\n\n    multiplicative() {\n      let left = this.unary();\n      let token;\n      while ((token = this.expect('*', '/', '%'))) {\n        left = { type: AST.BinaryExpression, operator: token.text, left: left, right: this.unary() };\n      }\n      return left;\n    }\n\n    unary() {\n      let token;\n      if ((token = this.expect('+', '-', '!'))) {\n        return { type: AST.UnaryExpression, operator: token.text, prefix: true, argument: this.unary() };\n      } else {\n        return this.primary();\n      }\n    }\n\n    primary() {\n      let primary;\n      if (this.expect('(')) {\n        primary = this.filterChain();\n        this.consume(')');\n      } else if (this.expect('[')) {\n        primary = this.arrayDeclaration();\n      } else if (this.expect('{')) {\n        primary = this.object();\n      } else if (this.constants.hasOwnProperty(this.peek().text)) {\n        primary = copy(this.constants[this.consume().text]);\n      } else if (this.peek().identifier) {\n        primary = this.identifier();\n      } else if (this.peek().constant) {\n        primary = this.constant();\n      } else {\n        this.throwError('not a primary expression', this.peek());\n      }\n\n      let next;\n      while ((next = this.expect('(', '[', '.'))) {\n        if (next.text === '[') {\n          primary = { type: AST.MemberExpression, object: primary, property: this.expression(), computed: true };\n          this.consume(']');\n        } else if (next.text === '.') {\n          primary = { type: AST.MemberExpression, object: primary, property: this.identifier(), computed: false };\n        } else {\n          this.throwError('IMPOSSIBLE');\n        }\n      }\n      return primary;\n    }\n\n    filter(baseExpression) {\n      let args = [baseExpression];\n      let result = { type: AST.CallExpression, callee: this.identifier(), arguments: args, filter: true };\n\n      while (this.expect(':')) {\n        args.push(this.expression());\n      }\n\n      return result;\n    }\n\n    identifier() {\n      let token = this.consume();\n      if (!token.identifier) {\n        this.throwError('is not a valid identifier', token);\n      }\n      return { type: AST.Identifier, name: token.text };\n    }\n\n    constant() {\n      // TODO check that it is a constant\n      return { type: AST.Literal, value: this.consume().value };\n    }\n\n    arrayDeclaration() {\n      let elements = [];\n      if (this.peekToken().text !== ']') {\n        do {\n          if (this.peek(']')) {\n            // Support trailing commas\n            break;\n          }\n          elements.push(this.expression());\n        } while (this.expect(','));\n      }\n      this.consume(']');\n\n      return { type: AST.ArrayExpression, elements: elements };\n    }\n\n    object() {\n      let properties = [], property;\n      if (this.peekToken().text !== '}') {\n        do {\n          if (this.peek('}')) {\n            // Support trailing commas\n            break;\n          }\n          property = { type: AST.Property, kind: 'init' };\n          if (this.peek().constant) {\n            property.key = this.constant();\n          } else if (this.peek().identifier) {\n            property.key = this.identifier();\n          } else {\n            this.throwError('invalid key', this.peek());\n          }\n          this.consume(':');\n          property.value = this.expression();\n          properties.push(property);\n        } while (this.expect(','));\n      }\n      this.consume('}');\n\n      return { type: AST.ObjectExpression, properties: properties };\n    }\n\n    throwError(msg, token) {\n      throw Error(`Syntax Error: Token \\'${token.text}\\' ${msg} at column ${token.index + 1} of the expression [${this.text}] starting at [${this.text.substring(token.index)}].`);\n    }\n\n    consume(e1) {\n      if (this.tokens.length === 0) {\n        throw Error(`Unexpected end of expression: ${this.text}`);\n      }\n\n      let token = this.expect(e1);\n      if (!token) {\n        this.throwError('is unexpected, expecting [' + e1 + ']', this.peek());\n      }\n      return token;\n    }\n\n    peekToken() {\n      if (this.tokens.length === 0) {\n        throw Error(`Unexpected end of expression: ${this.text}`);\n      }\n      return this.tokens[0];\n    }\n\n    peek(e1, e2, e3, e4) {\n      return this.peekAhead(0, e1, e2, e3, e4);\n    }\n\n    peekAhead(i, e1, e2, e3, e4) {\n      if (this.tokens.length > i) {\n        let token = this.tokens[i];\n        let t = token.text;\n        if (t === e1 || t === e2 || t === e3 || t === e4 ||\n          (!e1 && !e2 && !e3 && !e4)) {\n          return token;\n        }\n      }\n      return false;\n    }\n\n    expect(e1, e2, e3, e4) {\n      let token = this.peek(e1, e2, e3, e4);\n      if (token) {\n        this.tokens.shift();\n        return token;\n      }\n      return false;\n    }\n  }\n\n  AST.ConditionalExpression = 'ConditionalExpression';\n  AST.LogicalExpression = 'LogicalExpression';\n  AST.BinaryExpression = 'BinaryExpression';\n  AST.UnaryExpression = 'UnaryExpression';\n  AST.CallExpression = 'CallExpression';\n  AST.MemberExpression = 'MemberExpression';\n  AST.Identifier = 'Identifier';\n  AST.Literal = 'Literal';\n  AST.ArrayExpression = 'ArrayExpression';\n  AST.Property = 'Property';\n  AST.ObjectExpression = 'ObjectExpression';\n\n  AST.PRECEDENCE = {\n    [AST.ConditionalExpression]: 1,\n    [AST.LogicalExpression]: 1,\n    [AST.BinaryExpression]: 2,\n    [AST.UnaryExpression]: 3,\n    [AST.CallExpression]: 4,\n    [AST.MemberExpression]: 5,\n    [AST.Identifier]: 6,\n    [AST.Literal]: 6,\n    [AST.ObjectExpression]: 6,\n    [AST.Property]: 6,\n    [AST.ArrayExpression]: 6,\n  };\n\n  AST.LOGICAL_EXPRESSION_PRECEDENCE = {\n    '||': 1,\n    '&&': 2,\n  };\n\n  AST.BINARY_EXPRESSION_PRECEDENCE = {\n    '==': 1,\n    '!=': 1,\n    '<': 2,\n    '<=': 2,\n    '>': 2,\n    '>=': 2,\n    '+': 3,\n    '-': 3,\n    '*': 4,\n    '/': 4,\n    '%': 4,\n  };\n\n  exports.AST = AST;\n\n  const parser__DEFAULT_OPTIONS = {\n    LexerClass: Lexer,\n    ASTBuilderClass: AST\n  };\n\n  class Parser {\n    constructor(options) {\n      this.options = defaults(options, parser__DEFAULT_OPTIONS);\n      let lexer = new this.options.LexerClass();\n      this.astBuilder = new this.options.ASTBuilderClass(lexer);\n    }\n\n    precedence(expr1, expr2) {\n      var prec = AST.PRECEDENCE;\n      if (prec[expr1.type] < prec[expr2.type]) {\n        return -1;\n      } else if (prec[expr1.type] > prec[expr2.type]) {\n        return +1;\n      } else if (expr1.type === AST.LogicalExpression || expr1.type === AST.BinaryExpression) {\n        let oprec = expr1.type === AST.LogicalExpression ? AST.LOGICAL_EXPRESSION_PRECEDENCE : AST.BINARY_EXPRESSION_PRECEDENCE;\n        if (oprec[expr1.operator] < oprec[expr2.operator]) {\n          return -1;\n        } else if (oprec[expr1.operator] > oprec[expr2.operator]) {\n          return +1;\n        }\n      }\n      return 0;\n    }\n\n    toString(ast, parent) {\n      let str = expr => this.toString(expr, ast);\n      if (parent && this.precedence(ast, parent) < 0) {\n        return `(${this.toString(ast)})`;\n      }\n      switch (ast.type) {\n        case AST.ConditionalExpression:\n          return `${str(ast.test)} ? ${str(ast.consequent)} : ${str(ast.alternate)}`;\n        case AST.LogicalExpression:\n          return `${str(ast.left)} ${ast.operator} ${str(ast.right)}`;\n        case AST.BinaryExpression:\n          return `${str(ast.left)} ${ast.operator} ${str(ast.right)}`;\n        case AST.UnaryExpression:\n          return `${ast.operator}${str(ast.argument)}`;\n        case AST.CallExpression:\n          let args = ast.arguments.slice(1)\n            .map(arg => arg.type === AST.CallExpression ? `:(${str(arg)})` : `:${str(arg)}`).join('');\n          return `${str(ast.arguments[0])}|${ast.callee.name}${args}`;\n        case AST.MemberExpression:\n          if (!ast.computed && ast.property.type === AST.Identifier) {\n            return `${str(ast.object)}.${ast.property.name}`;\n          }\n          return `${str(ast.object)}[${str(ast.property)}]`;\n        case AST.Identifier:\n          return ast.name;\n        case AST.Literal:\n          return ast.value === undefined ? 'undefined' : JSON.stringify(ast.value);\n        case AST.ArrayExpression:\n          return `[${ast.elements.map(expr => this.toString(expr)).join(', ')}]`;\n        case AST.ObjectExpression:\n          let properties = ast.properties.map(expr => {\n            if (expr.key.type === AST.Identifier || expr.key.type === AST.Literal) {\n              return `${this.toString(expr.key)}: ${this.toString(expr.value)}`;\n            } else {\n              this.throwError('IMPOSSIBLE');\n            }\n          });\n          return `{${properties.join(', ')}}`;\n      }\n    }\n\n    eval(ast, locals = {}, filters = {}) {\n      let e = expr => this.eval(expr, locals, filters);\n      try {\n        switch (ast.type) {\n          case AST.ConditionalExpression:\n            return e(ast.test) ? e(ast.consequent) : e(ast.alternate);\n          case AST.LogicalExpression:\n            switch (ast.operator) {\n              case '&&':\n                return e(ast.left) && e(ast.right);\n              case '||':\n                return e(ast.left) || e(ast.right);\n              default:\n                this.throwError('IMPOSSIBLE');\n            }\n            break;\n          case AST.BinaryExpression:\n            let left = e(ast.left);\n            let right = e(ast.right);\n            switch (ast.operator) {\n              case '==':\n                return left === right;\n              case '!=':\n                return left !== right;\n              case '<':\n                return left < right;\n              case '<=':\n                return left <= right;\n              case '>':\n                return left > right;\n              case '>=':\n                return left >= right;\n              case '+':\n                return left + right;\n              case '-':\n                return left - right;\n              case '*':\n                return left * right;\n              case '/':\n                return left / right;\n              case '%':\n                return left % right;\n              default:\n                this.throwError('IMPOSSIBLE');\n            }\n            break;\n          case AST.UnaryExpression:\n            switch (ast.operator) {\n              case '+':\n                return +e(ast.argument);\n              case '-':\n                return -e(ast.argument);\n              case '!':\n                return !e(ast.argument);\n              default:\n                this.throwError('IMPOSSIBLE');\n            }\n            break;\n          case AST.CallExpression:\n            if (ast.callee.type !== AST.Identifier) {\n              this.throwError('IMPOSSIBLE');\n            }\n            if (!(ast.callee.name in filters)) {\n              this.throwError(`Reference error: [${ast.callee.name}] is not a defined filter`);\n            }\n            let callee = filters[ast.callee.name];\n            let args = ast.arguments.map(e);\n            return callee.apply(null, args);\n          case AST.MemberExpression:\n            if (ast.property.type === AST.Identifier && !ast.computed) {\n              return e(ast.object)[ast.property.name];\n            }\n            return e(ast.object)[e(ast.property)];\n          case AST.Identifier:\n            if (!(ast.name in locals)) {\n              this.throwError(`Reference error: [${ast.name}] is not a defined variable`);\n            }\n            return locals[ast.name];\n          case AST.Literal:\n            return ast.value;\n          case AST.ArrayExpression:\n            return ast.elements.map(e);\n          case AST.ObjectExpression:\n            let res = {};\n            ast.properties.forEach(prop => {\n              if (prop.key.type === AST.Identifier) {\n                res[prop.key.name] = e(prop.value);\n              } else {\n                res[e(prop.key)] = e(prop.value);\n              }\n            });\n            return res;\n        }\n      } catch (err) {\n        if (err.bubble) {\n          throw err;\n        }\n        let info = (err.message || 'No info available');\n        this.throwError(`There was an error evaluating \\`${this.toString(ast)}\\` (${info})`, true);\n      }\n    }\n\n    throwError(msg, bubble = false) {\n      let err = Error(`Parse Error: ${msg}`);\n      err.bubble = bubble;\n      throw err;\n    }\n\n    parse(text) {\n      let ast = this.astBuilder.ast(text);\n      return (locals = {}, filters = {}) => this.eval(ast, locals, filters);\n    }\n  }\n\n  exports.Parser = Parser;\n\n  'use strict';\n\n}));\n"],"sourceRoot":"/source/"}